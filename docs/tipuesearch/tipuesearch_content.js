var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Formath Formath is a linear algebra framework that is focused on implementing the fundamental numerical linear algebra procedures. Formath includes a vector and matrix types which model rank1 and rank2 arrays, respectively. These types allow for the modularization of vector and matrix operations. Note This Library is a work in process and is the process of me learning how to implement fundamental numerical algorithms from the ground up. This package is currently configured to my system, as it is intended principally as a learning experience. Developer Info Evan Voyles Learning Fortran by writing Fortran","tags":"home","loc":"index.html"},{"title":"vector.f90 â€“ Fortran Program","text":"Contents Modules vector_m Source Code vector.f90 Source Code module vector_m !! Attempt to play around with a vector object !! A vector, v has the following operations: !! !! Addition with another vector !! Multiplication with a scalar !! Inner product !! Norm (which norm?) !! Projection of a onto b !! !! ! // TODO Add support for array operations !! The internal representaion of a vector is an allocatable array. !! This way we can use the fundamental data of an array within our specific class use iso_fortran_env , only : real64 , real32 , int32 , int64 ! use formath implicit none private public :: operator ( * ), operator ( / ) !, deallocate_vector_data real ( real64 ), parameter :: vector_epsilon = 1 d - 14 type , public :: vector private real ( real64 ), dimension (:), allocatable :: v integer :: dim = 0 contains private procedure , public :: size => vector_size !! Return the number of elements of the currently allocated vector procedure , public :: clear => clear_vector !! Deallocate the data, set dim to 0 procedure , public :: print_info => vector_print_info !! Print diagnostic information about the vector procedure , public :: print => vector_print_coordinates !! Print only the data stored in the vector object as a row vector procedure , public :: at => vector_at_index !! Return the element x_i generic , public :: set => set_int_ , set_r32_ , set_r64_ !! Set the value of the element x_i at index i procedure , public :: length => vector_euclidiean_norm !! Calculate the euclidean norm of a vector v procedure , public :: pnorm => vector_pnorm !! Calculate the pnorm of a vector v procedure , public :: normalize => vector_normalize !! Normalize the elements of the passed vector v !! Normaliz**e** is a **subroutine** such that it alters the elements of the passed vector v to avoid costs of copying involved with a function procedure , public :: normalized => vector_normalized !! Return a normalized vector n pointing in the same direction as v !!@Note !! The function normaliz**ed** is a **function** such that it returns a normalized version of the passed vector v procedure , public :: orthogonalize => vector_orthogonalize !! Orthogonalize a vector v against a passed **normalized** vector n !!@Note !!A future version may just check if the passed vector is normalized by testing a \"normalized\" logical type that will be stored in a vector. procedure , public :: orthogonalized => vector_orthogonalized !! Return a vector v that is orthogonalized against a passed **normalized** vector n !!@Note !! This is a function that returns a new vector v procedure , public :: orthonormalize => vector_orthonormalize !! Orthogonalize and normalize a vector v against a passed **normalized** vector n !!@Note !! This is a subroutine that modifies the passed vector v procedure , public :: orthonormalized => vector_orthonormalized !! Return an orthogonalized and normalized vector v against a passed **normalized** vector n !!@Note !! This is a function that returns a new vector v procedure , public :: householder_transform => vector_householder_sub !! Rotate a passed vector v about the hyper plane described by the passed **normalized** vector n !!@Note !! This is a subroutine that modifies the passed vector procedure , public :: eye => vector_constructor_eye procedure , public :: is_ortho => vector_is_orthogonal procedure , public :: is_normal => vector_is_normal procedure , public :: data => vector_as_array procedure , public :: zero => vector_zero procedure , public :: allocated => vector_is_allocated procedure , public :: alloc_ => allocate_vector_data procedure , public :: dealloc_ => deallocate_vector_data procedure :: new_ => new_constructor procedure :: dot_ => vector_dot_vector procedure :: proj_ => vector_proj_vector procedure :: outer_ => vector_outer_vector procedure :: householder_ => vector_householder procedure :: householder_normal_ => vector_find_householder_normal procedure :: conform_ => vector_conform procedure :: scalar_mult_int_ => vector_times_scalar_int procedure :: scalar_mult_r32_ => vector_times_scalar_r32 procedure :: scalar_mult_r64_ => vector_times_scalar_r64 procedure :: scalar_div_int_ => vector_div_scalar_int procedure :: scalar_div_r32_ => vector_div_scalar_r32 procedure :: scalar_div_r64_ => vector_div_scalar_r64 procedure :: set_int_ => vector_set_index_int procedure :: set_r32_ => vector_set_index_r32 procedure :: set_r64_ => vector_set_index_r64 procedure :: minus_ => vector_minus_vector procedure :: unary_minus_ => vector_unary_minus procedure :: plus_ => vector_plus_vector !===============Operators Functions==================! generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_vector_ , from_int_ , & from_r32_ , from_r64_ generic , public :: operator (. dot .) => dot_ generic , public :: operator (. inner .) => dot_ generic , public :: operator (. outer .) => outer_ generic , public :: operator (. proj .) => proj_ generic , public :: operator (. hh .) => householder_ generic , public :: operator (. hhnorm .) => householder_normal_ generic , public :: operator ( * ) => scalar_mult_int_ , scalar_mult_r32_ , scalar_mult_r64_ generic , public :: operator (. o .) => hadamard_vec_ generic , public :: operator ( / ) => scalar_div_int_ , scalar_div_r32_ , scalar_div_r64_ , div_vec_ generic , public :: operator ( + ) => plus_ generic , public :: operator ( - ) => minus_ , unary_minus_ !===============Operator Subroutines==================! ! The point of an operator subroutine is to alter the passed object. This cuts down on copying ! the data between functions generic , public :: times => times_int_sub_ , times_r32_sub_ , times_r64_sub_ , times_vec_sub_ generic , public :: div => div_int_sub_ , div_r32_sub_ , div_r64_sub_ , div_vec_sub_ generic , public :: proj => project_onto_sub_ generic , public :: plus => plus_vector_sub_ generic , public :: minus => minus_vector_sub_ procedure :: times_int_sub_ => vector_times_scalar_int_sub procedure :: times_r32_sub_ => vector_times_scalar_r32_sub procedure :: times_r64_sub_ => vector_times_scalar_r64_sub procedure :: times_vec_sub_ => vector_times_vector_sub procedure :: div_int_sub_ => vector_div_scalar_int_sub procedure :: div_r32_sub_ => vector_div_scalar_r32_sub procedure :: div_r64_sub_ => vector_div_scalar_r64_sub procedure :: div_vec_sub_ => vector_div_vector_sub procedure :: project_onto_sub_ => vector_proj_vector_sub procedure :: plus_vector_sub_ => vector_plus_vector_sub procedure :: minus_vector_sub_ => vector_minus_vector_sub procedure :: from_int_ => vector_from_int procedure :: from_r32_ => vector_from_r32 procedure :: from_r64_ => vector_from_r64 procedure :: from_array_int_ => vector_from_array_int procedure :: from_array_r32_ => vector_from_array_r32 procedure :: from_array_r64_ => vector_from_array_r64 procedure :: from_vector_ => vector_from_vector procedure :: hadamard_vec_ => vector_hadamard_vector procedure :: div_vec_ => vector_div_vector final :: vector_destructor end type interface vector !! Construct a vector object <br> !!@Note !!A vector can be instantiated from integer and real data types but the underlying data will always !!be stored using double precision. !! !! The following code snippet shows all of the valid ways to construct a new vector !!```fortran !! !!type(vector) :: v1, v2, v3, v4, v5, v6, v7, v8 !! !!v1 = vector([1, 2, 3]) !!v2 = vector([1.0, 2.0, 3.0]) !!v3 = vector([1.0d0, 2.0d0, 3.0d0]) !!v4 = vector(4) ! [0, 0, 0, 0] !!v5 = vector(5, 3) ! [3, 3, 3, 3, 3] !!v6 = vector(2, 2.0) ! [2, 2] !!v7 = vector(val=4.7d0, dim=3) ! [4.7, 4.7, 4.7] !!v8 = vector(v7) !!``` procedure :: vector_constructor_int procedure :: vector_constructor_r32 procedure :: vector_constructor_r64 procedure :: vector_constructor_dim procedure :: vector_constructor_dim_value_int procedure :: vector_constructor_dim_value_r32 procedure :: vector_constructor_dim_value_r64 procedure :: vector_constructor_vector end interface interface operator ( * ) !! Extend multiplication operator to allow a scalar \\alpha times a vector such that procedure :: int_times_vector procedure :: r32_times_vector procedure :: r64_times_vector end interface interface operator ( / ) !! Extend division operator to allow a scalar divided by a vector procedure :: int_div_vector procedure :: r32_div_vector procedure :: r64_div_vector end interface contains !=============================================================================! !=                               Constructors                                =! !=============================================================================! pure subroutine new_constructor ( self , dim ) !! allocate the proper space for the elements of vector v and set the dimension to dim class ( vector ), intent ( inout ) :: self !! v integer , intent ( in ) :: dim !! n self % dim = dim allocate ( self % v ( dim )) end subroutine pure function vector_constructor_int ( array ) result ( this ) !! Construct a vector v from an array of integers integer , dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function pure function vector_constructor_r32 ( array ) result ( this ) !! Construct a vector v from an array of single precision reals real ( real32 ), dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function pure function vector_constructor_r64 ( array ) result ( this ) !! Construct a vector v from an array of double precision reals real ( real64 ), dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function elemental function vector_constructor_dim ( dim ) result ( this ) !! Construct a vector by declaring its size !! Allocate an n-dimensional vector and fill its values with 0 integer , intent ( in ) :: dim !! n type ( vector ) :: this !! v call this % new_ ( dim ) this % v = 0 end function elemental function vector_constructor_dim_value_int ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with integer val integer , intent ( in ) :: dim !! n integer , intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_dim_value_r32 ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with single precision real val integer , intent ( in ) :: dim !! n real ( real32 ), intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_dim_value_r64 ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with double precision real val integer , intent ( in ) :: dim !! n real ( real64 ), intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_vector ( v1 ) result ( v2 ) !! Construct a vector from another vector !! @Note !!Not very efficient due do the multiple copies that occur (About three times slower than assigment) class ( vector ), intent ( in ) :: v1 type ( vector ) :: v2 v2 = v1 end function elemental function vector_constructor_eye ( self , dim , col ) result ( v2 ) !! Construct a vector v that is equal to the colth column of the Identity matrix I_{dim} !! The dim and col parameters are both optional. If the dim parameter is absent, then take the colth !! column from the identity matrix whose dimension is v_{dim}. If the col parameter is missing, set its default !! value to the dimension. !!```fortran !!type(vector) :: v1, i1, i2, i3 !! !!v1 = vector(4, 0) ! Initialize a vector with dimension 4 and all 0 elements !! !!i1 = v1%eye() ! Return [0, 0, 0, 1] !!i2 = v1%eye(col = 3) ! Return [0, 0, 1, 0] !!i3 = v1%eye(dim=5, col=2) ! Return [0, 1, 0, 0, 0] !!``` class ( vector ), intent ( in ) :: self !! v integer , intent ( in ), optional :: dim !! Dimension of the Identity matrix integer , intent ( in ), optional :: col !! Column to extract integer :: dim_ integer :: col_ type ( vector ) :: v2 !! colth column of the Identity matrix I_{dim} if ( present ( dim )) then dim_ = dim else dim_ = self % dim end if if ( present ( col )) then col_ = col else col_ = dim_ end if v2 = vector ( dim_ , 0 ) call v2 % set ( col_ , 1 ) end function elemental subroutine clear_vector ( self ) !! Deallocate a vector v if it is allocated, set the dimension equal to 0 class ( vector ), intent ( inout ) :: self !! v if ( self % allocated ()) then call self % dealloc_ () else self % dim = 0 end if end subroutine elemental subroutine allocate_vector_data ( self , dim ) !! Allocate the underlying array containing v's data and set v's dimension to dim class ( vector ), intent ( inout ) :: self !! v integer , intent ( in ) :: dim !! n integer :: ierr allocate ( self % v ( dim ), STAT = ierr ) self % dim = dim if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine elemental subroutine deallocate_vector_data ( self ) !! Deallocate the underlying array containing v's elements class ( vector ), intent ( inout ) :: self !! v integer :: ierr deallocate ( self % v , STAT = ierr ) self % dim = 0 if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine !=============================================================================! !=                         Assigment Functions                               =! !=============================================================================! pure subroutine vector_from_int ( self , val ) !! Assign a vector v to an int value. If v is already allocated, fill the elements with val. If v !! is not already allocated, create a new vector of dimension 1 and set the element equal to val class ( vector ), intent ( inout ) :: self !! v integer , intent ( in ) :: val !! Value used to fill v if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_r32 ( self , val ) !! Assign a vector v to single precision value. If v is already allocated, fill the elements with val. If v !! is not already allocated, create a new vector of dimension 1 and set the element equal to val class ( vector ), intent ( inout ) :: self !! v real ( real32 ), intent ( in ) :: val !! Value used to fill v if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_r64 ( self , val ) !! Assign a vector v to a double precision value. If v is already allocated, fill the elements with val. If v !! is not already allocated, create a new vector of dimension 1 and set the element equal to val class ( vector ), intent ( inout ) :: self !! v real ( real64 ), intent ( in ) :: val !! Value used to fill v if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_array_int ( self , array ) !! Assign a vector v to an array of integers. !! @Note !! The underlying data is stored with double precision floating values, but a vector can be created from !! any numeric type class ( vector ), intent ( inout ) :: self integer , dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r32 ( self , array ) !! Assign a vector v to an array of integers. class ( vector ), intent ( inout ) :: self real ( real32 ), dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r64 ( self , array ) !! Assign a vector v to an array of integers. class ( vector ), intent ( inout ) :: self real ( real64 ), dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine elemental subroutine vector_from_vector ( self , v1 ) !! Copy the elements of a vector v_1 into v class ( vector ), intent ( inout ) :: self !! v class ( vector ), intent ( in ) :: v1 !! v_1 self % dim = v1 % dim self % v = v1 % v ! Copy the array contents end subroutine !=============================================================================! !=                            State Functions                                =! !=============================================================================! elemental function vector_conform ( self , v2 ) result ( bool ) !! Check if two vectors are conforming (have the same dimension) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 logical :: bool !! True when self%dim == v2%dim bool = ( self % dim == v2 % dim ) end function elemental function vector_is_orthogonal ( self , v2 , eps ) result ( bool ) !! Check if two vectors are orthogonal within a certain tolerance. class ( vector ), intent ( in ) :: self !! v class ( vector ), intent ( in ) :: v2 !! v_2 real ( real64 ), intent ( in ), optional :: eps !! \\epsilon logical :: bool !! True when \\abs{\\langle v, v2 \\rangle} < \\epsilon  if ( present ( eps )) then bool = abs ( self . dot . v2 ) < eps else bool = abs ( self . dot . v2 ) < vector_epsilon end if end function elemental function vector_is_normal ( self ) result ( bool ) !! Check if a vector is normal. A vector is normal if it's length is equal to 1 (within a tolerance) class ( vector ), intent ( in ) :: self logical :: bool if ( self % length () - 1 < vector_epsilon ) then bool = . true . else bool = . false . end if end function elemental function vector_is_allocated ( self ) result ( bool ) !! Check if a vector is allocated class ( vector ), intent ( in ) :: self logical :: bool if ( allocated ( self % v )) then bool = . true . else bool = . false . end if end function elemental function vector_size ( self ) result ( n ) !! Return the number of elements allocated for v class ( vector ), intent ( in ) :: self !! v integer :: n n = self % dim end function !=============================================================================! !=                            Print Functions                                =! !=============================================================================! subroutine vector_print_info ( self ) class ( vector ), intent ( in ) :: self if (. not . self % allocated ()) then write ( * , * ) \"Vector not allocated\" else write ( * , * ) \"dimension: \" , self % dim write ( * , * ) \"data: \" , self % v write ( * , * ) \"allocated: \" , self % allocated () end if end subroutine subroutine vector_print_coordinates ( self ) class ( vector ), intent ( in ) :: self print * , self % v end subroutine !=============================================================================! !=                           Access Functions                                =! !=============================================================================! elemental function vector_at_index ( self , index ) result ( x_n ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: index real ( real64 ) :: x_n if ( index > self % dim ) error stop \"out of bounds error\" x_n = self % v ( index ) end function elemental subroutine vector_set_index_int ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index integer , intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r32 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real32 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r64 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real64 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = val end subroutine pure function vector_as_array ( self ) result ( array ) class ( vector ), intent ( in ) :: self real ( real64 ), dimension ( self % dim ) :: array array = self % v end function !=============================================================================! !=                             Norm Functions                                =! !=============================================================================! elemental function vector_euclidiean_norm ( self ) result ( length ) class ( vector ), intent ( in ) :: self real ( real64 ) :: length length = self % pnorm ( 2 ) end function elemental function vector_pnorm ( self , p ) result ( pnorm ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: p real ( real64 ) :: power , pnorm if ( p < 1 ) error stop \"P-norm must be greater than or equal to 1\" power = 1._real64 / p pnorm = sum ( self % v ** p ) ** power end function elemental subroutine vector_normalize ( self ) !! Normalize a vector such that its euclidian norm is 1 class ( vector ), intent ( inout ) :: self real ( real64 ) :: norm norm = self % length () self % v = self % v / norm end subroutine elemental subroutine vector_orthogonalize ( self , v2 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: self_copy self_copy = self call self % proj ( v2 ) call self % minus ( self_copy ) end subroutine elemental subroutine vector_orthonormalize ( self , v2 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 call self % orthogonalize ( v2 ) call self % normalize () end subroutine elemental function vector_normalized ( self ) result ( normalized_vector ) !! Normalize a vector such that its euclidian norm is 1 class ( vector ), intent ( in ) :: self type ( vector ) :: normalized_vector real ( real64 ) :: norm norm = self % length () normalized_vector = ( self / norm ) end function elemental function vector_orthogonalized ( self , v2 ) result ( v3 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 v3 = self . proj . v2 v3 = self - v3 end function elemental function vector_orthonormalized ( self , v2 ) result ( v3 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 v3 = self % orthogonalized ( v2 ) call v3 % normalize () end function !=============================================================================! !=                            Operator Functions                             =! !=============================================================================! elemental function vector_dot_vector ( self , v2 ) result ( inner_product ) !! Calculate the inner product of two vectors class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ) :: inner_product if ( self % conform_ ( v2 )) then inner_product = sum ( self % v * v2 % v ) else error stop \"Cannot take the inner product of nonconforming vectors\" end if end function elemental function vector_proj_vector ( self , v2 ) result ( v3 ) !! Project vector self ONTO v2 proj_v2(self) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 real ( real64 ) :: scalar scalar = ( self . dot . v2 ) / ( v2 . dot . v2 ) v3 = v2 * scalar ! Allocate the space for a new vector end function pure function vector_outer_vector ( self , v2 ) result ( array ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ), dimension ( self % dim , v2 % dim ) :: array integer :: i do i = 1 , self % dim array ( i ,:) = self % at ( i ) * v2 % data () end do end function elemental function vector_householder ( self , normal ) result ( rotated ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: normal !! MUST BE A UNIT VECTOR type ( vector ) :: rotated rotated = self - ( 2 * ( self . inner . normal ) * normal ) end function function vector_find_householder_normal ( self , destination ) result ( normal ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: destination type ( vector ) :: normal print * , \"Destination set as: \" , destination % data () normal = self - destination call normal % normalize () end function elemental function vector_plus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new_ ( self % dim ) v3 % v = self % v + v2 % v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_minus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new_ ( self % dim ) v3 % v = self % v - v2 % v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_times_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_hadamard_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" v3 = self % v * v2 % v end function elemental function vector_div_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" v3 = self % v / v2 % v end function elemental function vector_div_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function int_times_vector ( scalar , vec ) result ( v2 ) integer , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function r32_times_vector ( scalar , vec ) result ( v2 ) real ( real32 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function r64_times_vector ( scalar , vec ) result ( v2 ) real ( real64 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function int_div_vector ( scalar , vec ) result ( v2 ) integer , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function r32_div_vector ( scalar , vec ) result ( v2 ) real ( real32 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function r64_div_vector ( scalar , vec ) result ( v2 ) real ( real64 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function vector_unary_minus ( self ) result ( v2 ) class ( vector ), intent ( in ) :: self type ( vector ) :: v2 v2 = self * ( - 1 ) end function !=============================================================================! !=                         Operator Subroutines                              =! !=============================================================================! elemental subroutine vector_proj_vector_sub ( self , v2 ) !! Project vector self ONTO v2 proj_v2(self) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ) :: scalar scalar = ( self . dot . v2 ) / ( v2 . dot . v2 ) self = v2 * scalar ! Allocate the space for a new vector end subroutine elemental subroutine vector_plus_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if ( self % conform_ ( v2 )) then self % v = self % v + v2 % v else error stop \"Cannot add nonconforming vectors\" end if end subroutine elemental subroutine vector_householder_sub ( self , normal ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: normal !! MUST BE A UNIT VECTOR call self % minus ( 2 * ( self . proj . normal )) end subroutine elemental subroutine vector_minus_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if ( self % conform_ ( v2 )) then self % v = self % v - v2 % v else error stop \"Cannot add nonconforming vectors\" end if end subroutine elemental subroutine vector_times_scalar_int_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_times_scalar_r32_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_times_scalar_r64_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_div_scalar_int_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_div_scalar_r32_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_div_scalar_r64_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_unary_minus_sub ( self ) class ( vector ), intent ( inout ) :: self self % v = - self % v end subroutine elemental subroutine vector_times_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" self % v = self % v * v2 % v end subroutine elemental subroutine vector_div_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" self % v = self % v / v2 % v end subroutine !=============================================================================! !=                           Static Functions                                =! !=============================================================================! elemental subroutine vector_zero ( self , dim ) class ( vector ), intent ( inout ) :: self integer , intent ( in ), optional :: dim if ( present ( dim )) then call self % new_ ( dim ) else call self % new_ ( 1 ) end if self % v = 0 end subroutine !=============================================================================! !=                                Destructor                                 =! !=============================================================================! subroutine vector_destructor ( self ) type ( vector ), intent ( inout ) :: self write ( * , * ) \"vector_destructor called\" if ( self % allocated ()) then print * , \"deallocating fields\" deallocate ( self % v ) end if end subroutine !=============================================================================! !=                              Gram-Schmidt                                 =! !=============================================================================! end module","tags":"","loc":"sourcefile/vector.f90.html"},{"title":"matrix.f90 â€“ Fortran Program","text":"Contents Modules matrix_m Source Code matrix.f90 Source Code module matrix_m !! A matrix is a wrapper class for a rank 1 array of vector objects. <br> !! Matrices can be used to represent a variety of mathematical structures. This class is primarily used !! to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment !! of a rank2 array of any type, but the underlying data will be stored with double precision. <br> !! !!  Matrix multiplication will be consistent with the mathematical operation (matmul), and element wise multiplication !! shall be represented by the hadamard product (OPERATOR .o.) !! !!```fortran !!type(matrix) :: m, ortho_basis !! !!m = reshape([1, 2, 3, 4], [2, 2]) ! Create a 2x2 matrix !!print*, \"M: \" !!call m%print() !! !!ortho_basis = m%gram_schmidt() ! Compute an orthonormal basis using the Gram-Schmidt method !! !!print\"(A)\", \"Ortho:\" !!call ortho_basis%print()!! !!``` !! !!output: !! !!![test](../media/matrix_m_output.png) !! use vector_m use iso_fortran_env , only : real64 , real32 implicit none private type , public :: matrix private integer :: k = 1 !! Number of vectors integer :: n = 1 !! Dimension of vectors type ( vector ), dimension (:), pointer :: m !! The vectors stored in a matrix logical :: m_allocated = . false . !! Allocation status of pointer contains private generic , public :: new => new_ , new_matrix_ !! Create a new matrix procedure , public :: clear => clear_matrix !! Clear all of the elements of a matrix procedure , public :: print => print_matrix !! Print the contents of a matrix procedure , public :: vec => access_vector_matrix !! Get the kth vector in the matrix procedure , public :: at => at_index_matrix !! Get the element at the index (i, j) procedure , public :: gram_schmidt => gram_schmidt_matrix !! Compute an otrthonormal basis for the vector space spanned by the columns of a matrix procedure , public :: is_orthonormal => is_orthonormal_matrix !! Check whether a matrix is orthonormal procedure , public :: as_array => matrix_as_array !! Return a rank2 Fortran array procedure , public :: id => identity_matrix generic , public :: create_hh => create_hh_vec_ procedure , nopass :: create_hh_vec_ => matrix_create_householder_vec generic , public :: fill => fill_int_ , fill_r32_ , fill_r64_ procedure :: fill_int_ => matrix_fill_int procedure :: fill_r32_ => matrix_fill_r32 procedure :: fill_r64_ => matrix_fill_r64 procedure :: conform_ => matrix_conform procedure :: mult_conform => matrix_mult_conform !! Check if two matrices are conforming for matrix multiplication (The number of cols of A should match the number of rows of B) generic , public :: set => set_int_ , set_r32_ , set_r64_ !! Set the value of a_{i,j}) generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_matrix !! Assign the contents of a matrix from a rank2 Fortran array procedure :: new_ => new_matrix procedure :: new_matrix_ => new_matrix_from_matrix procedure , public :: get_row => matrix_get_row procedure , public :: get_col => matrix_get_col generic , public :: set_row => set_row_int_ , set_row_r32_ , set_row_r64_ , set_row_vec_ generic , public :: set_col => set_col_int_ , set_col_r32_ , set_col_r64_ , set_col_vec_ procedure :: set_row_int_ => matrix_set_row_array_int procedure :: set_row_r32_ => matrix_set_row_array_r32 procedure :: set_row_r64_ => matrix_set_row_array_r64 procedure :: set_row_vec_ => matrix_set_row_vec procedure :: set_col_int_ => matrix_set_col_array_int procedure :: set_col_r32_ => matrix_set_col_array_r32 procedure :: set_col_r64_ => matrix_set_col_array_r64 procedure :: set_col_vec_ => matrix_set_col_vec !=================Operator Functions===============! generic , public :: operator ( + ) => add_matrix_ !! Operator interface to add two matrices !!@Note !! As an operator, this procedure is a **function** which return a new matrix. !! use the functional operator equivalent, use [[]] generic , public :: operator ( - ) => minus_matrix_ !! Operator interface to subtract a matrix !!@Note !! As an operator, this procedure is a **function** which return a new matrix. !! use the functional operator equivalent, use [[]] generic , public :: operator ( * ) => times_matrix_ , times_vector_ !! Operator interface to multiply two matrices !!@Note !! As an operator, this procedure is a **function** which return a new matrix. !! use the functional operator equivalent, use [[]] generic , public :: operator (. o .) => hadamard_ !=================Operator Subroutines===============! generic , public :: plus => add_matrix_sub_ !! Subroutine interface to add two matrices !!@Note !! This subroutine will alter the passed matrix. To use the functional operator equivalent, use + ! generic, public :: times => times_matrix_sub_ generic , public :: minus => minus_matrix_sub_ !! Subroutine interface to add two matrices !!@Note !! This subroutine will alter the passed matrix. To use the functional operator equivalent, use + generic , public :: times => times_int_sub_ , times_r32_sub_ , times_r64_sub_ procedure :: hadamard_ => matrix_hadamard_matrix procedure :: add_matrix_ => matrix_add_matrix procedure :: add_matrix_sub_ => matrix_add_matrix_sub procedure :: minus_matrix_ => matrix_minus_matrix procedure :: minus_matrix_sub_ => matrix_minus_matrix_sub procedure :: times_matrix_ => matrix_times_matrix procedure :: times_int_sub_ => matrix_times_int_sub procedure :: times_r32_sub_ => matrix_times_r32_sub procedure :: times_r64_sub_ => matrix_times_r64_sub procedure :: times_vector_ => matrix_times_vector procedure :: from_array_int_ => matrix_from_rank2_array_int procedure :: from_array_r32_ => matrix_from_rank2_array_r32 procedure :: from_array_r64_ => matrix_from_rank2_array_r64 procedure :: from_matrix => matrix_from_matrix procedure :: set_int_ => set_index_matrix_int procedure :: set_r32_ => set_index_matrix_r32 procedure :: set_r64_ => set_index_matrix_r64 procedure :: alloc_ => allocate_matrix_data !! Allocate the space for an array containing the matrix's elements procedure :: dealloc_ => deallocate_matrix_data !! Deallocate the underlying container for a matrix's elements end type interface matrix !! Construct a matrix procedure :: matrix_ctr_nk procedure :: matrix_ctr_nk_int procedure :: matrix_ctr_nk_r32 procedure :: matrix_ctr_nk_r64 !! Construct a matrix by specifying its number of rows n and number of cols k procedure :: matrix_ctr_matrix procedure :: matrix_ctr_int procedure :: matrix_ctr_r32 procedure :: matrix_ctr_r64 end interface contains !=============================================================================! !=                          Constructor  Functions                           =! !=============================================================================! elemental subroutine new_matrix ( self , n , k ) !! Wipe the contents of a matrix and allocate the proper amount of space class ( matrix ), intent ( inout ) :: self !! Matrix object to wipe integer , intent ( in ) :: n !! Dimension of each constituent vector integer , intent ( in ) :: k !! Number of vectors call self % clear () if ( k <= 0 . or . n <= 0 ) error stop \"Cannot instantiate vector with 0 or negative dimension\" self % k = k self % n = n call self % alloc_ () end subroutine elemental function matrix_ctr_nk ( n , k ) result ( A ) !! Create a new n-by-k matrix A by passing the number of rows n and the number of columns k integer , intent ( in ) :: n !! The number of rows in m integer , intent ( in ) :: k !! The number of cols in m type ( matrix ) :: A call A % new_ ( n , k ) call A % fill ( 0 ) end function elemental function matrix_ctr_nk_int ( n , k , val ) result ( A ) !! Create a new n-by-k matrix A by passing the number of rows n and the number of columns k integer , intent ( in ) :: n !! The number of rows in m integer , intent ( in ) :: k !! The number of cols in m integer , intent ( in ) :: val type ( matrix ) :: A call A % new_ ( n , k ) call A % fill ( val ) end function elemental function matrix_ctr_nk_r32 ( n , k , val ) result ( A ) !! Create a new n-by-k matrix A by passing the number of rows n and the number of columns k integer , intent ( in ) :: n !! The number of rows in m integer , intent ( in ) :: k !! The number of cols in m real ( real32 ), intent ( in ) :: val type ( matrix ) :: A call A % new_ ( n , k ) call A % fill ( val ) end function elemental function matrix_ctr_nk_r64 ( n , k , val ) result ( A ) !! Create a new n-by-k matrix A by passing the number of rows n and the number of columns k integer , intent ( in ) :: n !! The number of rows in m integer , intent ( in ) :: k !! The number of cols in m real ( real64 ), intent ( in ) :: val type ( matrix ) :: A call A % new_ ( n , k ) call A % fill ( val ) end function pure function matrix_ctr_int ( array ) result ( A ) !! Create a new n-by-k matrix A by passing a rank2 integer array integer , dimension (:,:), intent ( in ) :: array type ( matrix ) :: A A = array end function pure function matrix_ctr_r32 ( array ) result ( A ) !! Create a new n-by-k matrix A by passing a rank2 integer array real ( real32 ), dimension (:,:), intent ( in ) :: array type ( matrix ) :: A A = array end function pure function matrix_ctr_r64 ( array ) result ( A ) !! Create a new n-by-k matrix A by passing a rank2 integer array real ( real64 ), dimension (:,:), intent ( in ) :: array type ( matrix ) :: A A = array end function pure function matrix_ctr_matrix ( m2 ) result ( A ) !! Create a new n-by-k matrix A by passing a rank2 integer array class ( matrix ), intent ( in ) :: m2 type ( matrix ) :: A A = m2 end function elemental subroutine new_matrix_from_matrix ( self , m2 ) !! Wipe the contents of a matrix and allocate the proper amount of space class ( matrix ), intent ( inout ) :: self !! Matrix object to wipe class ( matrix ), intent ( in ) :: m2 !! Matrix object to wipe call self % clear () self % k = m2 % k self % n = m2 % n call self % alloc_ () end subroutine pure subroutine matrix_from_rank2_array_int ( self , array ) !! Assign a matrix from a rank2 integer array class ( matrix ), intent ( inout ) :: self integer , dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r32 ( self , array ) !! Assign a matrix from a rank2 single precision real array class ( matrix ), intent ( inout ) :: self real ( real32 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r64 ( self , array ) !! Assign a matrix from a rank2 double precision array class ( matrix ), intent ( inout ) :: self real ( real64 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine elemental subroutine matrix_from_matrix ( self , m ) !! class ( matrix ), intent ( inout ) :: self class ( matrix ), intent ( in ) :: m integer :: i self % n = m % n self % k = m % k call self % new ( m % n , m % k ) do i = 1 , self % k self % m ( i ) = m % vec ( i ) end do end subroutine elemental subroutine matrix_from_val_int ( self , val ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: val if ( self % m_allocated ) then call self % fill ( val ) else self = matrix ( 1 , 1 , val ) end if end subroutine elemental subroutine matrix_from_val_r32 ( self , val ) class ( matrix ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: val if ( self % m_allocated ) then call self % fill ( val ) else self = matrix ( 1 , 1 , val ) end if end subroutine elemental subroutine matrix_from_val_r64 ( self , val ) class ( matrix ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: val if ( self % m_allocated ) then call self % fill ( val ) else self = matrix ( 1 , 1 , val ) end if end subroutine elemental subroutine matrix_fill_int ( self , val ) ! Fill the matrix, don't ask any questions class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: val integer :: i do i = 1 , self % k self % m ( i ) = val end do end subroutine elemental subroutine matrix_fill_r32 ( self , val ) ! Fill the matrix, don't ask any questions class ( matrix ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: val integer :: i do i = 1 , self % k self % m ( i ) = val end do end subroutine elemental subroutine matrix_fill_r64 ( self , val ) ! Fill the matrix, don't ask any questions class ( matrix ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: val integer :: i do i = 1 , self % k self % m ( i ) = val end do end subroutine elemental subroutine clear_matrix ( self ) class ( matrix ), intent ( inout ) :: self self % k = 0 self % n = 0 if ( self % m_allocated ) then call self % dealloc_ () end if end subroutine elemental subroutine allocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr allocate ( self % m ( self % k ), STAT = ierr ) call self % m % zero ( self % n ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . true . end subroutine elemental subroutine deallocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr call self % m % dealloc_ () deallocate ( self % m , STAT = ierr ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . false . end subroutine subroutine print_matrix ( self ) class ( matrix ), intent ( in ) :: self character ( 10 ) :: num_fmt character ( 100 ) :: fmt integer :: i , j write ( num_fmt , \"(I0)\" ) self % k fmt = \"(\" // num_fmt // \"(G11.5, 2X))\" ! fmt = \"(\" // num_fmt // \"(G0, 2X))\" do i = 1 , self % n print fmt , ( self % at ( i , j ), j = 1 , self % k ) end do end subroutine !=============================================================================! !=                           Inquiry Functions                               =! !=============================================================================! elemental function at_index_matrix ( self , i , j ) result ( element ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ) :: element element = self % m ( j )% at ( i ) end function elemental subroutine set_index_matrix_int ( self , i , j , x ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector integer , intent ( in ) :: x call self % m ( j )% set ( i , x ) end subroutine elemental subroutine set_index_matrix_r32 ( self , i , j , x ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real32 ), intent ( in ) :: x call self % m ( j )% set ( i , x ) end subroutine elemental subroutine set_index_matrix_r64 ( self , i , j , x ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ), intent ( in ) :: x call self % m ( j )% set ( i , x ) end subroutine elemental function access_vector_matrix ( self , v ) result ( vec ) !! Get a copy of the vth vector class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: v type ( vector ) :: vec if ( v < 1 . or . v > self % k ) error stop \"Out of bounds index\" vec = self % m ( v ) end function elemental function matrix_get_row ( self , i ) result ( row_i ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith row type ( vector ) :: row_i integer :: irow row_i = vector ( self % k ) ! Create vector with dimension = number of self's cols do irow = 1 , self % k call row_i % set ( irow , self % at ( i , irow )) end do end function elemental function matrix_get_col ( self , j ) result ( col_j ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: j !! jth row type ( vector ) :: col_j col_j = self % m ( j ) end function elemental subroutine matrix_set_col_vec ( self , j , vec ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: j !! Column number class ( vector ), intent ( in ) :: vec self % m ( j ) = vec end subroutine pure subroutine matrix_set_col_array_int ( self , j , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: j !! Column number integer , dimension (:), intent ( in ) :: array if ( size ( array ) /= self % n ) error stop \"Length of passed array not compatible with matrix n\" self % m ( j ) = array end subroutine pure subroutine matrix_set_col_array_r32 ( self , j , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: j !! Column number real ( real32 ), dimension (:), intent ( in ) :: array if ( size ( array ) /= self % n ) error stop \"Length of passed array not compatible with matrix n\" self % m ( j ) = array end subroutine pure subroutine matrix_set_col_array_r64 ( self , j , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: j !! Column number real ( real64 ), dimension (:), intent ( in ) :: array if ( size ( array ) /= self % n ) error stop \"Length of passed array not compatible with matrix n\" self % m ( j ) = array end subroutine elemental subroutine matrix_set_row_vec ( self , i , vec ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! Row number class ( vector ), intent ( in ) :: vec integer :: icol if ( vec % size () /= self % k ) error stop \"Length of passed array not compatible with matrix k\" do icol = 1 , self % k call self % set ( i , icol , vec % at ( icol )) end do end subroutine pure subroutine matrix_set_row_array_int ( self , i , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! Row number integer , dimension (:), intent ( in ) :: array integer :: icol if ( size ( array ) /= self % k ) error stop \"Length of passed array not compatible with matrix k\" do icol = 1 , self % k call self % set ( i , icol , array ( icol )) end do end subroutine pure subroutine matrix_set_row_array_r32 ( self , i , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! Row number real ( real32 ), dimension (:), intent ( in ) :: array integer :: icol if ( size ( array ) /= self % k ) error stop \"Length of passed array not compatible with matrix k\" do icol = 1 , self % k call self % set ( i , icol , array ( icol )) end do end subroutine pure subroutine matrix_set_row_array_r64 ( self , i , array ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: i !! Row number real ( real64 ), dimension (:), intent ( in ) :: array integer :: icol if ( size ( array ) /= self % k ) error stop \"Length of passed array not compatible with matrix k\" do icol = 1 , self % k call self % set ( i , icol , array ( icol )) end do end subroutine elemental function gram_schmidt_matrix ( self ) result ( ortho ) class ( matrix ), intent ( in ) :: self type ( matrix ) :: ortho integer i , j , n , k n = self % n k = self % k if ( k > n ) k = n !! If there are more vectors than the dimension of the vector, only output n vectors call ortho % new ( n , k ) ! print *, \"dimension of input basis = \", self%n ! print *, \"number of basis vectors = \", self%k ! print *, \"orthonormal_basis set to 0\" ortho % m ( 1 ) = self % m ( 1 )% normalized () do i = 2 , k ortho % m ( i ) = self % m ( i ) do j = 1 , i - 1 ortho % m ( i ) = ortho % m ( i ) - ( ortho % m ( i ) . proj . ortho % m ( j )) ! ortho%m(i) = (ortho%m(i) .proj. ortho%m(j)) - ortho%m(i) end do call ortho % m ( i )% normalize () end do end function elemental function is_orthonormal_matrix ( self ) result ( bool ) class ( matrix ), intent ( in ) :: self logical :: bool integer :: i , j if ( all ( self % m % is_normal ())) then do i = 1 , self % k do j = i + 1 , self % k if (. not . self % m ( i )% is_ortho ( self % m ( j ))) then bool = . false . return end if end do end do bool = . true . else bool = . false . end if end function pure function matrix_as_array ( self ) result ( array ) class ( matrix ), intent ( in ) :: self real ( real64 ), dimension ( self % n , self % k ) :: array integer :: j do j = 1 , self % k array (:, j ) = self % m ( j )% data () end do end function elemental function matrix_conform ( self , m2 ) result ( bool ) !! Check if two matrices are conforming (have the same dimensions) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 logical :: bool !! True when self%dim == v2%dim bool = ( self % k == m2 % k . and . self % n == m2 % n ) end function elemental function matrix_mult_conform ( self , m2 ) result ( bool ) !! Check if two matrices are conforming (have the same dimensions) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 logical :: bool !! True when self%k == v2%n bool = ( self % k == m2 % n ) end function !=============================================================================! !=                           Function Operators                              =! !=============================================================================! elemental function matrix_add_matrix ( self , m2 ) result ( m3 ) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 type ( matrix ) :: m3 if (. not . self % conform_ ( m2 )) error stop \"Cannot add nonconforming matrices\" m3 = self call m3 % m % plus ( m2 % m ) end function elemental function matrix_minus_matrix ( self , m2 ) result ( m3 ) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 type ( matrix ) :: m3 if (. not . self % conform_ ( m2 )) error stop \"Cannot add nonconforming matrices\" m3 = self call m3 % m % minus ( m2 % m ) end function function matrix_times_matrix ( self , m2 ) result ( m3 ) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 type ( matrix ) :: m3 integer :: i , j if (. not . self % conform_ ( m2 )) error stop \"Cannot add nonconforming matrices\" m3 = matrix ( self % n , m2 % k ) do i = 1 , m3 % n do j = 1 , m3 % k call m3 % set ( i , j , ( self % get_row ( i ) . dot . m2 % get_col ( j ))) ! The i,j element is equal to the ith row of self times the jth column of m2 end do end do end function function matrix_times_vector ( self , v ) result ( v2 ) class ( matrix ), intent ( in ) :: self class ( vector ), intent ( in ) :: v type ( vector ) :: v2 integer :: i if ( self % k /= v % size ()) error stop \"Cannot add nonconforming matrices\" v2 = vector ( self % n ) do i = 1 , self % n call v2 % set ( i , self % get_row ( i ) . dot . v ) end do end function elemental function matrix_hadamard_matrix ( self , m2 ) result ( m3 ) class ( matrix ), intent ( in ) :: self class ( matrix ), intent ( in ) :: m2 type ( matrix ) :: m3 if (. not . self % conform_ ( m2 )) error stop \"Cannot multiply two nonconforming matrices\" m3 = self call m3 % m % times ( m2 % m ) ! Use elemental function call to multiply all the columns by eachother!!! end function !=============================================================================! !=                          Subroutine Operators                             =! !=============================================================================! elemental subroutine matrix_add_matrix_sub ( self , m2 ) !! Subroutine interface to add two matrices !!@Note !! This subroutine will alter the passed matrix. To use the functional operator equivalent, use + class ( matrix ), intent ( inout ) :: self class ( matrix ), intent ( in ) :: m2 if (. not . self % conform_ ( m2 )) error stop \"Cannot add nonconforming matrices\" call self % m % plus ( m2 % m ) end subroutine elemental subroutine matrix_minus_matrix_sub ( self , m2 ) class ( matrix ), intent ( inout ) :: self class ( matrix ), intent ( in ) :: m2 if (. not . self % conform_ ( m2 )) error stop \"Cannot add nonconforming matrices\" call self % m % minus ( m2 % m ) end subroutine elemental subroutine matrix_times_int_sub ( self , val ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: val call self % m % times ( val ) end subroutine elemental subroutine matrix_times_r32_sub ( self , val ) class ( matrix ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: val call self % m % times ( val ) end subroutine elemental subroutine matrix_times_r64_sub ( self , val ) class ( matrix ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: val call self % m % times ( val ) end subroutine elemental function identity_matrix ( self , n ) result ( I_n ) !! Return I_n class ( matrix ), intent ( in ) :: self integer , optional , value :: n type ( matrix ) :: I_n integer :: n_ , i if ( present ( n )) then n_ = n else n_ = self % n end if I_n = matrix ( n_ , n_ ) do i = 1 , n_ call I_n % set ( i , i , 1 ) end do end function pure function matrix_create_householder_vec ( normal ) result ( m ) class ( vector ), intent ( in ) :: normal !! A UNIT vector that is normal to a plane of rotation type ( matrix ) :: m , op m = m % id ( normal % size ()) op = normal . outer . normal call op % times ( 2 ) call m % minus ( op ) end function end module","tags":"","loc":"sourcefile/matrix.f90.html"},{"title":"gs_test_2.f90 â€“ Fortran Program","text":"Contents Programs gs_test_2 Source Code gs_test_2.f90 Source Code program gs_test_2 use iso_fortran_env use matrix_m use vector_m implicit none type ( matrix ) :: m , ortho m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) print * , \"M: \" call m % print () ortho = m % gram_schmidt () print \"(A)\" , \"Ortho: \" call ortho % print () end program","tags":"","loc":"sourcefile/gs_test_2.f90.html"},{"title":"mat_oper_test.f90 â€“ Fortran Program","text":"Contents Programs mat_subop_test Source Code mat_oper_test.f90 Source Code program mat_subop_test ! Test the function operators for matrices use matrix_m use vector_m use iso_fortran_env , only : real64 implicit none type ( matrix ) :: m1 , m2 , m3 , m4 , m5 , m6 , i1 , m7 , hh type ( vector ) :: v1 , v2 , v3 , v4 , v5 m1 = reshape ([ 2 , 3 , 4 , 5 ], [ 2 , 2 ]) m2 = reshape ([ 1 , 0 , 0 , 1 ], [ 2 , 2 ]) v1 = [ 2 , 4 ] m3 = m1 * m2 call m1 % print () print * , \" times \" call m2 % print () print * , \" equals \" call m3 % print () v2 = m1 * v1 call m1 % print () print * , \"times\" call v1 % print () print * , \" equals \" call v2 % print () m4 = m1 . o . m2 call m4 % print () print * m5 = m1 + m2 call m1 % print () print * , \"plus\" call m2 % print () print * , \"equals\" call m5 % print () m6 = m4 - m3 call m4 % print () print * , \"minus\" call m3 % print () print * , \"equals\" call m6 % print () i1 = i1 % id ( 10 ) call i1 % print () print * , \"V1 = \" call v1 % print () print * , \"V2 = \" call v2 % print () m7 = v1 . outer . v2 print * , \"Outer product: \" call m7 % print () v3 = [ 1 , 2 , 3 ] v4 = [ 1 , 0 , 0 ] v5 = v3 . hh . v4 print * , v3 % data (), \" rotated over \" , v4 % data (), \" = \" , v5 % data () hh = hh % create_hh ( v4 ) call hh % print () hh = hh % create_hh ( vector ([ 0 , 1 , 0 ])) call hh % print () hh = hh % create_hh ( vector ([ 0 , 0 , 1 ])) call hh % print () v5 = hh * v3 call v5 % print () end program","tags":"","loc":"sourcefile/mat_oper_test.f90.html"},{"title":"mat_subop_test.f90 â€“ Fortran Program","text":"Contents Programs mat_subop_test Source Code mat_subop_test.f90 Source Code program mat_subop_test ! Test the subroutine operators for matrices use matrix_m use vector_m use iso_fortran_env , only : real64 implicit none type ( matrix ) :: m1 , m2 , m3 end program","tags":"","loc":"sourcefile/mat_subop_test.f90.html"},{"title":"mat_ctor_test.f90 â€“ Fortran Program","text":"Contents Programs mat_ctor_test Source Code mat_ctor_test.f90 Source Code program mat_ctor_test use matrix_m use vector_m use iso_fortran_env , only : real64 , real32 implicit none type ( matrix ) :: m1 , m2 , m3 , m4 , m5 , m6 m1 = matrix ( reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ], [ 4 , 3 ])) m2 = matrix ( real ( reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ], [ 4 , 3 ]), real32 )) m3 = matrix ( real ( reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ], [ 4 , 3 ]), real64 )) m4 = matrix ( 3 , 3 , 13 ) m5 = matrix ( m4 ) call m5 % set_col ( 3 , [ 1 , 2 , 3 ]) m6 = matrix ( 3 , 3 ) call m1 % print () call m2 % print () call m3 % print () call m4 % print () call m5 % print () call m6 % print () end program","tags":"","loc":"sourcefile/mat_ctor_test.f90.html"},{"title":"mat_asgn_test.f90 â€“ Fortran Program","text":"Contents Programs m_asgn_test Source Code mat_asgn_test.f90 Source Code program m_asgn_test use matrix_m use vector_m use iso_fortran_env , only : real64 implicit none type ( matrix ) :: m1 , m2 , m3 , m4 type ( vector ) :: v1 m1 = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ 3 , 2 ]) m2 = m1 m3 = m2 % as_array () call m3 % set_row ( 2 , [ 10 , 20 ]) call m3 % set_col ( 2 , [ 100 , 200 , 300 ]) v1 = m3 % get_col ( 1 ) call v1 % print () v1 = m3 % get_col ( 2 ) call v1 % print () m4 = real ( m3 % as_array (), real64 ) call m4 % set_row ( 3 , [ 50 , 60 ]) call m1 % print () call m2 % print () call m3 % print () call m4 % print () end program","tags":"","loc":"sourcefile/mat_asgn_test.f90.html"},{"title":"vec_test_2.f90 â€“ Fortran Program","text":"Contents Programs vec_test_2 Source Code vec_test_2.f90 Source Code program vec_test_2 use matrix_m use vector_m use iso_fortran_env implicit none type ( vector ) :: v1 v1 = vector ( 2 ) v1 = [ 1 , 2 ] call v1 % print () v1 = [ 2 ] call v1 % print_info () call test_sub ( v1 , [ 2._real64 ]) contains subroutine test_sub ( self , array ) class ( vector ) :: self real ( real64 ), dimension (:) :: array if ( size ( array ) /= self % size ()) then error stop \"Please don't compile me\" end if print * , \"Array with dim =\" , size ( array ), \" passed\" end subroutine end program","tags":"","loc":"sourcefile/vec_test_2.f90.html"},{"title":"v_sub_op_speed.f90 â€“ Fortran Program","text":"Contents Programs v_op_speed_sub Source Code v_sub_op_speed.f90 Source Code program v_op_speed_sub use vector_m implicit none integer , parameter :: N_LOOPS = 1E8 integer :: i type ( vector ) :: v1 v1 = [ 1 , 5 , - 4 , 10 ] do i = 1 , N_LOOPS call v1 % times ( 5 ) end do end program","tags":"","loc":"sourcefile/v_sub_op_speed.f90.html"},{"title":"v_n_assigment_test.f90 â€“ Fortran Program","text":"Contents Programs v_n_assigment_test Source Code v_n_assigment_test.f90 Source Code program v_n_assigment_test !! Test whether assigment or construction is faster use vector_m implicit none type ( vector ) :: v1 integer :: i integer , parameter :: N_LOOPS = 1E7 do i = 1 , N_LOOPS v1 = [ 1 , 3 , 4 , 5 ] end do call v1 % print_info () end program","tags":"","loc":"sourcefile/v_n_assigment_test.f90.html"},{"title":"v_operator_test.f90 â€“ Fortran Program","text":"Contents Programs operator_test Source Code v_operator_test.f90 Source Code program operator_test !! Test the functional operators use vector_m use iso_fortran_env implicit none type ( vector ) :: v1 , v2 , v3 , res , z , x , y real ( real64 ) :: scal_res v1 = [ 1 , 2 , 4 ] v2 = [ 6 , 5 , 10 ] z = [ 0 , 0 , 1 ] x = [ 1 , 0 , 0 ] y = [ 0 , 1 , 0 ] scal_res = v1 . dot . v2 print * , \"Dot product of \" , v1 % data (), \" and \" , v2 % data (), \" = \" , scal_res v3 = v1 . proj . v2 v2 = v2 % normalized () v3 = v3 % normalized () scal_res = v2 . dot . v3 print * , \"Dot product of v2 and v3 = \" , scal_res res = v1 + v2 v1 = [ 1 , 5 , 8 ] v2 = [ 1 , - 3 , - 5 ] res = v1 + v2 print * , \"v1: \" , v1 % data (), \" + \" , v2 % data (), \" = \" , res % data () res = v1 - v2 print * , \"v1: \" , v1 % data (), \" - \" , v2 % data (), \" = \" , res % data () res = v1 * 10 print * , \"v1: \" , v1 % data (), \" * 10 = \" , res % data () v2 = [ 100 , 6 , 5 ] res = v2 / 10 print * , \"v2: \" , v2 % data (), \" /10 = \" , res % data () res = v1 . o . v2 print * , \"v1: \" , v1 % data (), \" * \" , v2 % data (), \" = \" , res % data () res = v1 / v2 print * , \"v1: \" , v1 % data (), \" / \" , v2 % data (), \" = \" , res % data () res = 5 * v1 print * , \"5 * \" , v1 % data (), \" = \" , res % data () res = 5 / v1 print * , \"5 / \" , v1 % data (), \" = \" , res % data () res = - v1 print * , \"-(\" , v1 % data (), \") = \" , res % data () res = v1 % orthogonalized ( vector ([ 0 , 0 , 1 ])) print * , \"v1%orthogonalized([0, 0, 1]) = \" , res % data () print * , \"Scalar = \" , ( v1 . dot . z ) / ( z . dot . z ) res = v1 . proj . z print * , \"v1 .proj. z = \" , res % data () res = v1 % orthonormalized ( vector ([ 0 , 0 , 1 ])) print * , \"v1%orthogonormalized([0, 0, 1]) = \" , res % data () 99 format ( 80 ( \"=\" )) print 99 print 99 print * , \"House holder transformation tests\" print 99 print 99 res = v1 . hh . z print * , \"v1 .hh. z = \" , res % data () res = v1 . hh . y print * , \"v1 .hh. y = \" , res % data () res = v1 . hh . x print * , \"v1 .hh. x = \" , res % data () res = v1 . hhnorm . x ! res = res * -1/(res%at(1)) print * , \"v1 .hhnorm. x = \" , res % data () res = v1 . hh . res print * , \"v1 .hh. res = \" , res % data () end program","tags":"","loc":"sourcefile/v_operator_test.f90.html"},{"title":"v_assignment_test.f90 â€“ Fortran Program","text":"Contents Programs v_assignment_test Source Code v_assignment_test.f90 Source Code program v_assignment_test !! Test whether the assignments work as expected use vector_m implicit none type ( vector ) :: v1 , v2 , v3 , v4 , v5 , v6 , v7 v1 = 4 v2 = [ 4 , 2 ] v3 = [ 1.0 , 2.0 ] v4 = [ 3.d0 , 5.7d0 , 10 9.d0 , - 5 0.d0 ] v5 = v4 v6 = v5 v6 = 1 5.0 v7 = vector ( 20 ) v7 = - 1 4.d0 call v1 % print_info () call v2 % print_info () call v3 % print_info () call v4 % print_info () call v5 % print_info () call v6 % print_info () call v7 % print_info () end program","tags":"","loc":"sourcefile/v_assignment_test.f90.html"},{"title":"v_operator_sub_test.f90 â€“ Fortran Program","text":"Contents Programs v_operator_sub_test Source Code v_operator_sub_test.f90 Source Code program v_operator_sub_test use vector_m implicit none type ( vector ) :: v1 , v2 , v3 v1 = [ 1 , 2 , 4 ] v2 = [ 6 , 5 , 10 ] v3 = v1 call v3 % proj ( v1 ) print * , v3 % data () print * , \"Starting v1: \" , v1 % data () print * , \"Starting v2: \" , v2 % data () call v1 % plus ( v2 ) print * , \"v1%plus(v2) = \" , v1 % data () call v1 % minus ( v2 ) print * , \"v1%minus(v2) = \" , v1 % data () call v1 % times ( v2 ) print * , \"v1%times(v2) = \" , v1 % data () call v1 % times ( 5 ) print * , \"v1%times(5) = \" , v1 % data () call v1 % div ( 100 ) print * , \"v1%div(100) = \" , v1 % data () call v1 % div ( v2 ) print * , \"v1%div(v2) = \" , v1 % data () call v1 % normalize () print * , \"v1%normalize() = \" , v1 % data () end program","tags":"","loc":"sourcefile/v_operator_sub_test.f90.html"},{"title":"v_constructor_test.f90 â€“ Fortran Program","text":"Contents Programs v_constructor_test Source Code v_constructor_test.f90 Source Code program v_constructor_test !! Test whether the assignments work as expected use vector_m implicit none type ( vector ) :: v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 v1 = vector ( 5 ) !! Create empty vector(zeros) with 5 elements v2 = vector ([ 1 , 2 , 3 ]) !! Create dim 3 vector from [1, 2, 3] v3 = vector ( 4 , 0 ) !! Create 4 dim vector and fill it with 0 v4 = vector ([ 1.0 , 3.0 , 4.0 , 5.0 , 3.0 ]) v5 = vector ( 5 , 1.6 ) v6 = vector ( 10 , 1.7d0 ) v7 = vector ([ 1.4d0 , - 1 4.d0 ]) v8 = vector ( v7 ) v9 = v8 % eye () v10 = v10 % eye ( 20 ) v11 = v11 % eye ( 5 , 3 ) v12 = v7 % eye ( col = 1 ) v13 = v4 % eye ( dim = 10 , col = 2 ) call v1 % print_info () call v2 % print_info () call v3 % print_info () call v4 % print_info () call v5 % print_info () call v6 % print_info () call v7 % print_info () call v8 % print () call v9 % print () call v10 % print () call v11 % print () call v12 % print () call v13 % print () end program","tags":"","loc":"sourcefile/v_constructor_test.f90.html"},{"title":"v_n_constructor_test.f90 â€“ Fortran Program","text":"Contents Programs v_n_constructor_test Source Code v_n_constructor_test.f90 Source Code program v_n_constructor_test !! Test whether assigment or construction is faster use vector_m implicit none type ( vector ) :: v1 integer :: i integer , parameter :: N_LOOPS = 1E7 do i = 1 , N_LOOPS v1 = vector ([ 1 , 3 , 4 , 5 ]) end do call v1 % print_info () end program","tags":"","loc":"sourcefile/v_n_constructor_test.f90.html"},{"title":"v_fnc_op_speed.f90 â€“ Fortran Program","text":"Contents Programs v_op_speed Source Code v_fnc_op_speed.f90 Source Code program v_op_speed use vector_m implicit none integer , parameter :: N_LOOPS = 1E8 integer :: i type ( vector ) :: v1 v1 = [ 1 , 5 , - 4 , 10 ] do i = 1 , N_LOOPS v1 = v1 * 5 end do end program","tags":"","loc":"sourcefile/v_fnc_op_speed.f90.html"},{"title":"vector â€“ Fortran Program ","text":"type, public :: vector Contents Constructor vector Finalization Procedures vector_destructor Type-Bound Procedures size clear print_info print at set length pnorm normalize normalized orthogonalize orthogonalized orthonormalize orthonormalized householder_transform eye is_ortho is_normal data zero allocated alloc_ dealloc_ assignment(=) operator(.dot.) operator(.inner.) operator(.outer.) operator(.proj.) operator(.hh.) operator(.hhnorm.) operator(*) operator(.o.) operator(/) operator(+) operator(-) times div proj plus minus Constructor public interface vector Construct a vector object Read moreâ€¦ private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector ) Finalization Procedures final :: vector_destructor private subroutine vector_destructor(self) Arguments Type Intent Optional Attributes Name type( vector ), intent(inout) :: self Type-Bound Procedures procedure, public :: size => vector_size Return the number of elements of the currently allocated vector private elemental function vector_size(self) result(n) Return the number of elements allocated for v Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self v Return Value integer procedure, public :: clear => clear_vector Deallocate the data, set dim to 0 private elemental subroutine clear_vector(self) Deallocate a vector v if it is allocated, set the dimension equal to 0 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v procedure, public :: print_info => vector_print_info Print diagnostic information about the vector private subroutine vector_print_info(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: print => vector_print_coordinates Print only the data stored in the vector object as a row vector private subroutine vector_print_coordinates(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: at => vector_at_index Return the element x_i private elemental function vector_at_index(self, index) result(x_n) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: index Return Value real(kind=real64) generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of the element x_i at index i private elemental subroutine vector_set_index_int(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index integer, intent(in) :: val private elemental subroutine vector_set_index_r32(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real32), intent(in) :: val private elemental subroutine vector_set_index_r64(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real64), intent(in) :: val procedure, public :: length => vector_euclidiean_norm Calculate the euclidean norm of a vector v private elemental function vector_euclidiean_norm(self) result(length) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64) procedure, public :: pnorm => vector_pnorm Calculate the pnorm of a vector v private elemental function vector_pnorm(self, p) result(pnorm) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: p Return Value real(kind=real64) procedure, public :: normalize => vector_normalize Normalize the elements of the passed vector v Normaliz e is a subroutine such that it alters the elements of the passed vector v to avoid costs of copying involved with a function private elemental subroutine vector_normalize(self) Normalize a vector such that its euclidian norm is 1 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public :: normalized => vector_normalized Return a normalized vector n pointing in the same direction as v Note The function normaliz ed is a function such that it returns a normalized version of the passed vector v private elemental function vector_normalized(self) result(normalized_vector) Normalize a vector such that its euclidian norm is 1 Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value type( vector ) procedure, public :: orthogonalize => vector_orthogonalize Orthogonalize a vector v against a passed normalized vector n Note A future version may just check if the passed vector is normalized by testing a \"normalized\" logical type that will be stored in a vector. private elemental subroutine vector_orthogonalize(self, v2) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 procedure, public :: orthogonalized => vector_orthogonalized Return a vector v that is orthogonalized against a passed normalized vector n Note This is a function that returns a new vector v private elemental function vector_orthogonalized(self, v2) result(v3) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: orthonormalize => vector_orthonormalize Orthogonalize and normalize a vector v against a passed normalized vector n Note This is a subroutine that modifies the passed vector v private elemental subroutine vector_orthonormalize(self, v2) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 procedure, public :: orthonormalized => vector_orthonormalized Return an orthogonalized and normalized vector v against a passed normalized vector n Note This is a function that returns a new vector v private elemental function vector_orthonormalized(self, v2) result(v3) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: householder_transform => vector_householder_sub Rotate a passed vector v about the hyper plane described by the passed normalized vector n Note This is a subroutine that modifies the passed vector private elemental subroutine vector_householder_sub(self, normal) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: normal MUST BE A UNIT VECTOR procedure, public :: eye => vector_constructor_eye private elemental function vector_constructor_eye(self, dim, col) result(v2) Construct a vector v that is equal to the col th column of the Identity matrix I_{dim} The dim and col parameters are both optional. If the dim parameter is absent, then take the col th\n column from the identity matrix whose dimension is v_{dim} . If the col parameter is missing, set its default\n value to the dimension. Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self v integer, intent(in), optional :: dim Dimension of the Identity matrix integer, intent(in), optional :: col Column to extract Return Value type( vector ) col th column of the Identity matrix I_{dim} procedure, public :: is_ortho => vector_is_orthogonal private elemental function vector_is_orthogonal(self, v2, eps) result(bool) Check if two vectors are orthogonal within a certain tolerance. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self v class( vector ), intent(in) :: v2 v_2 real(kind=real64), intent(in), optional :: eps \\epsilon Return Value logical True when \\abs{\\langle v, v2 \\rangle} < \\epsilon procedure, public :: is_normal => vector_is_normal private elemental function vector_is_normal(self) result(bool) Check if a vector is normal. A vector is normal if it's length is equal to 1 (within a tolerance) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: data => vector_as_array private pure function vector_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%dim) procedure, public :: zero => vector_zero private elemental subroutine vector_zero(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), optional :: dim procedure, public :: allocated => vector_is_allocated private elemental function vector_is_allocated(self) result(bool) Check if a vector is allocated Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: alloc_ => allocate_vector_data private elemental subroutine allocate_vector_data(self, dim) Allocate the underlying array containing v 's data and set v 's dimension to dim Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v integer, intent(in) :: dim n procedure, public :: dealloc_ => deallocate_vector_data private elemental subroutine deallocate_vector_data(self) Deallocate the underlying array containing v 's elements Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_vector_, from_int_, from_r32_, from_r64_ private pure subroutine vector_from_array_int(self, array) Assign a vector v to an array of integers. Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), dimension(:) :: array private pure subroutine vector_from_array_r32(self, array) Assign a vector v to an array of integers. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in), dimension(:) :: array private pure subroutine vector_from_array_r64(self, array) Assign a vector v to an array of integers. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in), dimension(:) :: array private elemental subroutine vector_from_vector(self, v1) Copy the elements of a vector v_1 into v Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v class( vector ), intent(in) :: v1 v_1 private pure subroutine vector_from_int(self, val) Assign a vector v to an int value. If v is already allocated, fill the elements with val . If v is not already allocated, create a new vector of dimension 1 and set the element equal to val Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v integer, intent(in) :: val Value used to fill v private pure subroutine vector_from_r32(self, val) Assign a vector v to single precision value. If v is already allocated, fill the elements with val . If v is not already allocated, create a new vector of dimension 1 and set the element equal to val Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v real(kind=real32), intent(in) :: val Value used to fill v private pure subroutine vector_from_r64(self, val) Assign a vector v to a double precision value. If v is already allocated, fill the elements with val . If v is not already allocated, create a new vector of dimension 1 and set the element equal to val Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self v real(kind=real64), intent(in) :: val Value used to fill v generic, public :: operator(.dot.) => dot_ private elemental function vector_dot_vector(self, v2) result(inner_product) Calculate the inner product of two vectors Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.inner.) => dot_ private elemental function vector_dot_vector(self, v2) result(inner_product) Calculate the inner product of two vectors Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.outer.) => outer_ private pure function vector_outer_vector(self, v2) result(array) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64),\n  dimension(self%dim, v2%dim) generic, public :: operator(.proj.) => proj_ private elemental function vector_proj_vector(self, v2) result(v3) Project vector self ONTO v2 proj_v2(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(.hh.) => householder_ private elemental function vector_householder(self, normal) result(rotated) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: normal MUST BE A UNIT VECTOR Return Value type( vector ) generic, public :: operator(.hhnorm.) => householder_normal_ private function vector_find_householder_normal(self, destination) result(normal) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: destination Return Value type( vector ) generic, public :: operator(*) => scalar_mult_int_, scalar_mult_r32_, scalar_mult_r64_ private elemental function vector_times_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) generic, public :: operator(.o.) => hadamard_vec_ private elemental function vector_hadamard_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(/) => scalar_div_int_, scalar_div_r32_, scalar_div_r64_, div_vec_ private elemental function vector_div_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(+) => plus_ private elemental function vector_plus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(-) => minus_, unary_minus_ private elemental function vector_minus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) private elemental function vector_unary_minus(self) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value type( vector ) generic, public :: times => times_int_sub_, times_r32_sub_, times_r64_sub_, times_vec_sub_ private elemental subroutine vector_times_scalar_int_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: scalar private elemental subroutine vector_times_scalar_r32_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in) :: scalar private elemental subroutine vector_times_scalar_r64_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in) :: scalar private elemental subroutine vector_times_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: div => div_int_sub_, div_r32_sub_, div_r64_sub_, div_vec_sub_ private elemental subroutine vector_div_scalar_int_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: scalar private elemental subroutine vector_div_scalar_r32_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in) :: scalar private elemental subroutine vector_div_scalar_r64_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in) :: scalar private elemental subroutine vector_div_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: proj => project_onto_sub_ private elemental subroutine vector_proj_vector_sub(self, v2) Project vector self ONTO v2 proj_v2(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: plus => plus_vector_sub_ private elemental subroutine vector_plus_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: minus => minus_vector_sub_ private elemental subroutine vector_minus_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2","tags":"","loc":"type/vector.html"},{"title":"matrix â€“ Fortran Program ","text":"type, public :: matrix Contents Constructor matrix Type-Bound Procedures new clear print vec at gram_schmidt is_orthonormal as_array id create_hh fill set assignment(=) get_row get_col set_row set_col operator(+) operator(-) operator(*) operator(.o.) plus minus times Constructor public interface matrix Construct a matrix private elemental function matrix_ctr_nk(n, k) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m Return Value type( matrix ) private elemental function matrix_ctr_nk_int(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m integer, intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r32(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real32), intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r64(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real64), intent(in) :: val Return Value type( matrix ) private pure function matrix_ctr_matrix(m2) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: m2 Return Value type( matrix ) private pure function matrix_ctr_int(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r32(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r64(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: array Return Value type( matrix ) Type-Bound Procedures generic, public :: new => new_, new_matrix_ Create a new matrix private elemental subroutine new_matrix(self, n, k) Wipe the contents of a matrix and allocate the proper amount of space Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self Matrix object to wipe integer, intent(in) :: n Dimension of each constituent vector integer, intent(in) :: k Number of vectors private elemental subroutine new_matrix_from_matrix(self, m2) Wipe the contents of a matrix and allocate the proper amount of space Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self Matrix object to wipe class( matrix ), intent(in) :: m2 Matrix object to wipe procedure, public :: clear => clear_matrix Clear all of the elements of a matrix private elemental subroutine clear_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self procedure, public :: print => print_matrix Print the contents of a matrix private subroutine print_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix private elemental function access_vector_matrix(self, v) result(vec) Get a copy of the vth vector Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: v Return Value type( vector ) procedure, public :: at => at_index_matrix Get the element at the index (i, j) private elemental function at_index_matrix(self, i, j) result(element) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector Return Value real(kind=real64) procedure, public :: gram_schmidt => gram_schmidt_matrix Compute an otrthonormal basis for the vector space spanned by the columns of a matrix private elemental function gram_schmidt_matrix(self) result(ortho) If there are more vectors than the dimension of the vector, only output n vectors Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value type( matrix ) procedure, public :: is_orthonormal => is_orthonormal_matrix Check whether a matrix is orthonormal private elemental function is_orthonormal_matrix(self) result(bool) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value logical procedure, public :: as_array => matrix_as_array Return a rank2 Fortran array private pure function matrix_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%n, self%k) procedure, public :: id => identity_matrix private elemental function identity_matrix(self, n) result(I_n) Return I_n Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, optional value :: n Return Value type( matrix ) generic, public :: create_hh => create_hh_vec_ private pure function matrix_create_householder_vec(normal) result(m) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: normal A UNIT vector that is normal to a plane of rotation Return Value type( matrix ) generic, public :: fill => fill_int_, fill_r32_, fill_r64_ private elemental subroutine matrix_fill_int(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: val private elemental subroutine matrix_fill_r32(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real32), intent(in) :: val private elemental subroutine matrix_fill_r64(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real64), intent(in) :: val generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of (a_{i,j}) private elemental subroutine set_index_matrix_int(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector integer, intent(in) :: x private elemental subroutine set_index_matrix_r32(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real32), intent(in) :: x private elemental subroutine set_index_matrix_r64(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real64), intent(in) :: x generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix Assign the contents of a matrix from a rank2 Fortran array private pure subroutine matrix_from_rank2_array_int(self, array) Assign a matrix from a rank2 integer array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r32(self, array) Assign a matrix from a rank2 single precision real array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real32), intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r64(self, array) Assign a matrix from a rank2 double precision array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real64), intent(in), dimension(:,:) :: array private elemental subroutine matrix_from_matrix(self, m) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self class( matrix ), intent(in) :: m procedure, public :: get_row => matrix_get_row private elemental function matrix_get_row(self, i) result(row_i) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i i th row Return Value type( vector ) procedure, public :: get_col => matrix_get_col private elemental function matrix_get_col(self, j) result(col_j) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: j j th row Return Value type( vector ) generic, public :: set_row => set_row_int_, set_row_r32_, set_row_r64_, set_row_vec_ private pure subroutine matrix_set_row_array_int(self, i, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i Row number integer, intent(in), dimension(:) :: array private pure subroutine matrix_set_row_array_r32(self, i, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i Row number real(kind=real32), intent(in), dimension(:) :: array private pure subroutine matrix_set_row_array_r64(self, i, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i Row number real(kind=real64), intent(in), dimension(:) :: array private elemental subroutine matrix_set_row_vec(self, i, vec) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: i Row number class( vector ), intent(in) :: vec generic, public :: set_col => set_col_int_, set_col_r32_, set_col_r64_, set_col_vec_ private pure subroutine matrix_set_col_array_int(self, j, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: j Column number integer, intent(in), dimension(:) :: array private pure subroutine matrix_set_col_array_r32(self, j, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: j Column number real(kind=real32), intent(in), dimension(:) :: array private pure subroutine matrix_set_col_array_r64(self, j, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: j Column number real(kind=real64), intent(in), dimension(:) :: array private elemental subroutine matrix_set_col_vec(self, j, vec) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: j Column number class( vector ), intent(in) :: vec generic, public :: operator(+) => add_matrix_ Operator interface to add two matrices Note As an operator, this procedure is a function which return a new matrix. \n use the functional operator equivalent, use [[]] private elemental function matrix_add_matrix(self, m2) result(m3) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self class( matrix ), intent(in) :: m2 Return Value type( matrix ) generic, public :: operator(-) => minus_matrix_ Operator interface to subtract a matrix Note As an operator, this procedure is a function which return a new matrix. \n use the functional operator equivalent, use [[]] private elemental function matrix_minus_matrix(self, m2) result(m3) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self class( matrix ), intent(in) :: m2 Return Value type( matrix ) generic, public :: operator(*) => times_matrix_, times_vector_ Operator interface to multiply two matrices Note As an operator, this procedure is a function which return a new matrix. \n use the functional operator equivalent, use [[]] private function matrix_times_matrix(self, m2) result(m3) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self class( matrix ), intent(in) :: m2 Return Value type( matrix ) private function matrix_times_vector(self, v) result(v2) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self class( vector ), intent(in) :: v Return Value type( vector ) generic, public :: operator(.o.) => hadamard_ private elemental function matrix_hadamard_matrix(self, m2) result(m3) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self class( matrix ), intent(in) :: m2 Return Value type( matrix ) generic, public :: plus => add_matrix_sub_ Subroutine interface to add two matrices Note This subroutine will alter the passed matrix. To use the functional operator equivalent, use + private elemental subroutine matrix_add_matrix_sub(self, m2) Subroutine interface to add two matrices Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self class( matrix ), intent(in) :: m2 generic, public :: minus => minus_matrix_sub_ Subroutine interface to add two matrices Note This subroutine will alter the passed matrix. To use the functional operator equivalent, use + private elemental subroutine matrix_minus_matrix_sub(self, m2) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self class( matrix ), intent(in) :: m2 generic, public :: times => times_int_sub_, times_r32_sub_, times_r64_sub_ private elemental subroutine matrix_times_int_sub(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: val private elemental subroutine matrix_times_r32_sub(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real32), intent(in) :: val private elemental subroutine matrix_times_r64_sub(self, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real64), intent(in) :: val","tags":"","loc":"type/matrix.html"},{"title":"vector â€“ Fortran Program","text":"public interface vector Construct a vector object Note A vector can be instantiated from integer and real data types but the underlying data will always\nbe stored using double precision. The following code snippet shows all of the valid ways to construct a new vector type ( vector ) :: v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 v1 = vector ([ 1 , 2 , 3 ]) v2 = vector ([ 1.0 , 2.0 , 3.0 ]) v3 = vector ([ 1.0d0 , 2.0d0 , 3.0d0 ]) v4 = vector ( 4 ) ! [0, 0, 0, 0] v5 = vector ( 5 , 3 ) ! [3, 3, 3, 3, 3] v6 = vector ( 2 , 2.0 ) ! [2, 2] v7 = vector ( val = 4.7d0 , dim = 3 ) ! [4.7, 4.7, 4.7] v8 = vector ( v7 ) Contents Module Procedures vector_constructor_int vector_constructor_r32 vector_constructor_r64 vector_constructor_dim vector_constructor_dim_value_int vector_constructor_dim_value_r32 vector_constructor_dim_value_r64 vector_constructor_vector Module Procedures private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector )","tags":"","loc":"interface/vector.html"},{"title":"operator(*) â€“ Fortran Program","text":"public interface operator(*) Extend multiplication operator to allow a scalar \\alpha times a vector such that Contents Module Procedures int_times_vector r32_times_vector r64_times_vector Module Procedures private elemental function int_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(*).html"},{"title":"operator(/) â€“ Fortran Program","text":"public interface operator(/) Extend division operator to allow a scalar divided by a vector Contents Module Procedures int_div_vector r32_div_vector r64_div_vector Module Procedures private elemental function int_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(SLASH).html"},{"title":"matrix â€“ Fortran Program","text":"public interface matrix Construct a matrix Contents Module Procedures matrix_ctr_nk matrix_ctr_nk_int matrix_ctr_nk_r32 matrix_ctr_nk_r64 matrix_ctr_matrix matrix_ctr_int matrix_ctr_r32 matrix_ctr_r64 Module Procedures private elemental function matrix_ctr_nk(n, k) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m Return Value type( matrix ) private elemental function matrix_ctr_nk_int(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m integer, intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r32(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real32), intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r64(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real64), intent(in) :: val Return Value type( matrix ) private pure function matrix_ctr_matrix(m2) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: m2 Return Value type( matrix ) private pure function matrix_ctr_int(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r32(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r64(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: array Return Value type( matrix )","tags":"","loc":"interface/matrix.html"},{"title":"test_sub â€“ Fortran Program","text":"subroutine test_sub(self, array) Arguments Type Intent Optional Attributes Name class( vector ) :: self real(kind=real64), dimension(:) :: array Contents None","tags":"","loc":"proc/test_sub.html"},{"title":"vector_m â€“ Fortran Program","text":"Attempt to play around with a vector object A vector, v has the following operations: Addition with another vector\n Multiplication with a scalar \n Inner product\n Norm (which norm?)\n Projection of a onto b The internal representaion of a vector is an allocatable array.\n This way we can use the fundamental data of an array within our specific class Uses iso_fortran_env Contents Interfaces vector operator(*) operator(/) Derived Types vector Interfaces public interface vector Construct a vector object Read moreâ€¦ private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector ) public interface operator(*) Extend multiplication operator to allow a scalar \\alpha times a vector such that private elemental function int_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) public interface operator(/) Extend division operator to allow a scalar divided by a vector private elemental function int_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Derived Types type, public :: vector Constructor Construct a vector object Read moreâ€¦ private pure function vector_constructor_int (array) Construct a vector v from an array of integers private pure function vector_constructor_r32 (array) Construct a vector v from an array of single precision reals private pure function vector_constructor_r64 (array) Construct a vector v from an array of double precision reals private elemental function vector_constructor_dim (dim) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 private elemental function vector_constructor_dim_value_int (dim, val) Construct a vector v of dimension n and fill its values with integer val private elemental function vector_constructor_dim_value_r32 (dim, val) Construct a vector v of dimension n and fill its values with single precision real val private elemental function vector_constructor_dim_value_r64 (dim, val) Construct a vector v of dimension n and fill its values with double precision real val private elemental function vector_constructor_vector (v1) Construct a vector from another vector Read moreâ€¦ Finalizations Procedures final :: vector_destructor","tags":"","loc":"module/vector_m.html"},{"title":"matrix_m â€“ Fortran Program","text":"A matrix is a wrapper class for a rank 1 array of vector objects. Matrices can be used to represent a variety of mathematical structures. This class is primarily used\n to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment \n of a rank2 array of any type, but the underlying data will be stored with double precision. Matrix multiplication will be consistent with the mathematical operation (matmul), and element wise multiplication\n shall be represented by the hadamard product (OPERATOR .o.) type ( matrix ) :: m , ortho_basis m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) ! Create a 2x2 matrix print * , \"M: \" call m % print () ortho_basis = m % gram_schmidt () ! Compute an orthonormal basis using the Gram-Schmidt method print \"(A)\" , \"Ortho:\" call ortho_basis % print () !! output: Uses vector_m iso_fortran_env Contents Interfaces matrix Derived Types matrix Interfaces public interface matrix Construct a matrix private elemental function matrix_ctr_nk(n, k) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m Return Value type( matrix ) private elemental function matrix_ctr_nk_int(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m integer, intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r32(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real32), intent(in) :: val Return Value type( matrix ) private elemental function matrix_ctr_nk_r64(n, k, val) result(A) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The number of rows in m integer, intent(in) :: k The number of cols in m real(kind=real64), intent(in) :: val Return Value type( matrix ) private pure function matrix_ctr_matrix(m2) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: m2 Return Value type( matrix ) private pure function matrix_ctr_int(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r32(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: array Return Value type( matrix ) private pure function matrix_ctr_r64(array) result(A) Create a new n -by- k matrix A by passing a rank2 integer array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: array Return Value type( matrix ) Derived Types type, public :: matrix Constructor Construct a matrix private elemental function matrix_ctr_nk (n, k) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k private elemental function matrix_ctr_nk_int (n, k, val) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k private elemental function matrix_ctr_nk_r32 (n, k, val) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k private elemental function matrix_ctr_nk_r64 (n, k, val) Create a new n -by- k matrix A by passing the number of rows n and the number of columns k private pure function matrix_ctr_matrix (m2) Create a new n -by- k matrix A by passing a rank2 integer array private pure function matrix_ctr_int (array) Create a new n -by- k matrix A by passing a rank2 integer array private pure function matrix_ctr_r32 (array) Create a new n -by- k matrix A by passing a rank2 integer array private pure function matrix_ctr_r64 (array) Create a new n -by- k matrix A by passing a rank2 integer array Type-Bound Procedures generic, public :: new => new_, new_matrix_ Create a new matrix procedure, public :: clear => clear_matrix Clear all of the elements of a matrix procedure, public :: print => print_matrix Print the contents of a matrix procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix procedure, public :: at => at_index_matrix Get the element at the index (i, j) procedure, public :: gram_schmidt => gram_schmidt_matrix Compute an otrthonormal basis for the vector space spanned by the columns of a matrix procedure, public :: is_orthonormal => is_orthonormal_matrix Check whether a matrix is orthonormal procedure, public :: as_array => matrix_as_array Return a rank2 Fortran array procedure, public :: id => identity_matrix generic, public :: create_hh => create_hh_vec_ generic, public :: fill => fill_int_, fill_r32_, fill_r64_ generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of (a_{i,j}) generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix Assign the contents of a matrix from a rank2 Fortran array procedure, public :: get_row => matrix_get_row procedure, public :: get_col => matrix_get_col generic, public :: set_row => set_row_int_, set_row_r32_, set_row_r64_, set_row_vec_ generic, public :: set_col => set_col_int_, set_col_r32_, set_col_r64_, set_col_vec_ generic, public :: operator(+) => add_matrix_ Operator interface to add two matrices Read moreâ€¦ generic, public :: operator(-) => minus_matrix_ Operator interface to subtract a matrix Read moreâ€¦ generic, public :: operator(*) => times_matrix_, times_vector_ Operator interface to multiply two matrices Read moreâ€¦ generic, public :: operator(.o.) => hadamard_ generic, public :: plus => add_matrix_sub_ Subroutine interface to add two matrices Read moreâ€¦ generic, public :: minus => minus_matrix_sub_ Subroutine interface to add two matrices Read moreâ€¦ generic, public :: times => times_int_sub_, times_r32_sub_, times_r64_sub_","tags":"","loc":"module/matrix_m.html"},{"title":"gs_test_2 â€“ Fortran Program","text":"Uses iso_fortran_env matrix_m vector_m Contents Variables m ortho Variables Type Attributes Name Initial type( matrix ) :: m type( matrix ) :: ortho","tags":"","loc":"program/gs_test_2.html"},{"title":"mat_subop_test â€“ Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables m1 m2 m3 m4 m5 m6 i1 m7 hh v1 v2 v3 v4 v5 Variables Type Attributes Name Initial type( matrix ) :: m1 type( matrix ) :: m2 type( matrix ) :: m3 type( matrix ) :: m4 type( matrix ) :: m5 type( matrix ) :: m6 type( matrix ) :: i1 type( matrix ) :: m7 type( matrix ) :: hh type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: v4 type( vector ) :: v5","tags":"","loc":"program/mat_subop_test.html"},{"title":"mat_subop_test â€“ Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables m1 m2 m3 Variables Type Attributes Name Initial type( matrix ) :: m1 type( matrix ) :: m2 type( matrix ) :: m3","tags":"","loc":"program/mat_subop_test~2.html"},{"title":"mat_ctor_test â€“ Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables m1 m2 m3 m4 m5 m6 Variables Type Attributes Name Initial type( matrix ) :: m1 type( matrix ) :: m2 type( matrix ) :: m3 type( matrix ) :: m4 type( matrix ) :: m5 type( matrix ) :: m6","tags":"","loc":"program/mat_ctor_test.html"},{"title":"m_asgn_test â€“ Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables m1 m2 m3 m4 v1 Variables Type Attributes Name Initial type( matrix ) :: m1 type( matrix ) :: m2 type( matrix ) :: m3 type( matrix ) :: m4 type( vector ) :: v1","tags":"","loc":"program/m_asgn_test.html"},{"title":"vec_test_2 â€“ Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables v1 Subroutines test_sub Variables Type Attributes Name Initial type( vector ) :: v1 Subroutines subroutine test_sub (self, array) Arguments Type Intent Optional Attributes Name class( vector ) :: self real(kind=real64), dimension(:) :: array","tags":"","loc":"program/vec_test_2.html"},{"title":"v_op_speed_sub â€“ Fortran Program","text":"Uses vector_m Contents Variables N_LOOPS i v1 Variables Type Attributes Name Initial integer, parameter :: N_LOOPS = 1E8 integer :: i type( vector ) :: v1","tags":"","loc":"program/v_op_speed_sub.html"},{"title":"v_n_assigment_test â€“ Fortran Program","text":"Uses vector_m Test whether assigment or construction is faster Contents Variables v1 i N_LOOPS Variables Type Attributes Name Initial type( vector ) :: v1 integer :: i integer, parameter :: N_LOOPS = 1E7","tags":"","loc":"program/v_n_assigment_test.html"},{"title":"operator_test â€“ Fortran Program","text":"Uses vector_m iso_fortran_env Test the functional operators Contents Variables v1 v2 v3 res z x y scal_res Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: res type( vector ) :: z type( vector ) :: x type( vector ) :: y real(kind=real64) :: scal_res","tags":"","loc":"program/operator_test.html"},{"title":"v_assignment_test â€“ Fortran Program","text":"Uses vector_m Test whether the assignments work as expected Contents Variables v1 v2 v3 v4 v5 v6 v7 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: v4 type( vector ) :: v5 type( vector ) :: v6 type( vector ) :: v7","tags":"","loc":"program/v_assignment_test.html"},{"title":"v_operator_sub_test â€“ Fortran Program","text":"Uses vector_m Contents Variables v1 v2 v3 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3","tags":"","loc":"program/v_operator_sub_test.html"},{"title":"v_constructor_test â€“ Fortran Program","text":"Uses vector_m Test whether the assignments work as expected Create empty vector(zeros) with 5 elements\n Create dim 3 vector from [1, 2, 3]\n Create 4 dim vector and fill it with 0 Contents Variables v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: v4 type( vector ) :: v5 type( vector ) :: v6 type( vector ) :: v7 type( vector ) :: v8 type( vector ) :: v9 type( vector ) :: v10 type( vector ) :: v11 type( vector ) :: v12 type( vector ) :: v13","tags":"","loc":"program/v_constructor_test.html"},{"title":"v_n_constructor_test â€“ Fortran Program","text":"Uses vector_m Test whether assigment or construction is faster Contents Variables v1 i N_LOOPS Variables Type Attributes Name Initial type( vector ) :: v1 integer :: i integer, parameter :: N_LOOPS = 1E7","tags":"","loc":"program/v_n_constructor_test.html"},{"title":"v_op_speed â€“ Fortran Program","text":"Uses vector_m Contents Variables N_LOOPS i v1 Variables Type Attributes Name Initial integer, parameter :: N_LOOPS = 1E8 integer :: i type( vector ) :: v1","tags":"","loc":"program/v_op_speed.html"}]}