var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is ejovo13. Developer Info Evan Voyles Learning Fortran by writing Fortran","tags":"home","loc":"index.html"},{"title":"vector.f90 â€“ Fortran Program","text":"Contents Modules vector_m Source Code vector.f90 Source Code module vector_m !! Attempt to play around with a vector object !! A vector has the following operations: !! !! Addition with another vector !! Multiplication with a scalar !! Inner product !! Norm (which norm?) !! Projection of a onto b !! !! !! The internal representaion of a vector is an array of fixed size, pointed to by a pointer. !! This way we can use the fundamental data of an array within our specific class use iso_fortran_env , only : real64 , real32 , int32 , int64 implicit none private public :: print_basis , nd_test , gram_schmidt , is_orthonormal , deallocate_vector_data real ( real64 ), parameter :: vector_epsilon = 1 d - 14 type , public :: vector private integer :: dim = 1 real ( real64 ), dimension (:), allocatable :: v contains private procedure , public :: new => new_vector procedure , public :: new_ => new_constructor procedure , public :: clear => clear_vector !! Deallocate the data, set v_allocated to false, set dim to 0 procedure , public :: print_info => vector_print_info procedure , public :: print => vector_print_coordinates procedure , public :: at => vector_at_index generic , public :: set => set_int_ , set_r32_ , set_r64_ procedure , public :: length => vector_euclidiean_norm procedure , public :: pnorm => vector_pnorm procedure , public :: normalize => vector_normalize procedure , public :: is_ortho => vector_is_orthogonal procedure , public :: is_normal => vector_is_normal procedure , public :: as_array => vector_as_array procedure , public :: zero => vector_zero procedure , public :: allocated => vector_is_allocated procedure , public :: alloc_ => allocate_vector_data procedure , public :: dealloc_ => deallocate_vector_data procedure :: dot_ => vector_dot_vector procedure :: proj_ => vector_proj_vector procedure :: conform_ => vector_conform procedure :: scalar_mult_int_ => vector_times_scalar_int procedure :: scalar_mult_r32_ => vector_times_scalar_r32 procedure :: scalar_mult_r64_ => vector_times_scalar_r64 procedure :: scalar_div_int_ => vector_div_scalar_int procedure :: scalar_div_r32_ => vector_div_scalar_r32 procedure :: scalar_div_r64_ => vector_div_scalar_r64 procedure :: set_int_ => vector_set_index_int procedure :: set_r32_ => vector_set_index_r32 procedure :: set_r64_ => vector_set_index_r64 procedure :: minus_ => vector_minus_vector procedure :: plus_ => vector_plus_vector generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_vector_ generic , public :: operator (. dot .) => dot_ generic , public :: operator (. proj .) => proj_ generic , public :: operator ( * ) => scalar_mult_int_ , scalar_mult_r32_ , scalar_mult_r64_ generic , public :: operator ( / ) => scalar_div_int_ , scalar_div_r32_ , scalar_div_r64_ generic , public :: operator ( + ) => plus_ generic , public :: operator ( - ) => minus_ procedure :: from_array_int_ => vector_from_array_int procedure :: from_array_r32_ => vector_from_array_r32 procedure :: from_array_r64_ => vector_from_array_r64 procedure :: from_vector_ => vector_from_vector final :: vector_destructor end type type , public :: nd_vector ( n ) integer , len :: n = 3 real ( real64 ), dimension ( n ) :: data contains ! procedure :: test => nd_test end type interface vector procedure :: vector_constructor_int procedure :: vector_constructor_r32 procedure :: vector_constructor_r64 procedure :: vector_constructor_dim end interface ! private :: vector_constructor_int, vector_constructor_r32, vector_constructor_r64, new_vector, allocate_vector_data, & !            deallocate_vector_data, vector_from_array_int, vector_from_array_r32, vector_from_array_r64, vector_dot_vector, & !            vector_conform, vector_is_associated, vector_destructor, vector_print_info, vector_print_coordinates, vector_at_index contains subroutine nd_test ( nd ) class ( nd_vector ( n =* )), intent ( in ) :: nd print * , \"nd has n = \" , nd % n end subroutine !=============================================================================! !=                               Constructors                                =! !=============================================================================! pure subroutine new_constructor ( self , dim ) ! allocate the proper space for our vector and set the dimension class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: dim self % dim = dim allocate ( self % v ( dim )) end subroutine pure function vector_constructor_int ( array ) result ( this ) integer , dimension (:), intent ( in ) :: array type ( vector ) :: this call this % new_ ( size ( array )) this % v = real ( array , real64 ) end function pure function vector_constructor_r32 ( array ) result ( this ) real ( real32 ), dimension (:), intent ( in ) :: array type ( vector ) :: this call this % new_ ( size ( array )) this % v = real ( array , real64 ) end function pure function vector_constructor_r64 ( array ) result ( this ) real ( real64 ), dimension (:), intent ( in ) :: array type ( vector ) :: this call this % new_ ( size ( array )) this % v = array end function elemental function vector_constructor_dim ( dim ) result ( this ) integer , intent ( in ) :: dim type ( vector ) :: this call this % new_ ( dim ) this % v = 0 end function elemental subroutine new_vector ( self , dim ) class ( vector ), intent ( inout ) :: self integer , optional , intent ( in ) :: dim call self % clear () if (. not . present ( dim )) then self % dim = 1 else if ( dim <= 0 ) error stop \"Cannot instantiate vector with 0 or negative dimension\" self % dim = dim end if call self % alloc_ () end subroutine elemental subroutine clear_vector ( self ) class ( vector ), intent ( inout ) :: self self % dim = 0 if ( self % allocated ()) then call self % dealloc_ () end if end subroutine elemental subroutine allocate_vector_data ( self ) class ( vector ), intent ( inout ) :: self integer :: ierr allocate ( self % v ( self % dim ), STAT = ierr ) if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine elemental subroutine deallocate_vector_data ( self ) class ( vector ), intent ( inout ) :: self integer :: ierr deallocate ( self % v , STAT = ierr ) if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine !=============================================================================! !=                         Assigment Functions                               =! !=============================================================================! pure subroutine vector_from_array_int ( self , array ) class ( vector ), intent ( inout ) :: self integer , dimension ( self % dim ), intent ( in ) :: array self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r32 ( self , array ) class ( vector ), intent ( inout ) :: self real ( real32 ), dimension ( self % dim ), intent ( in ) :: array self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r64 ( self , array ) class ( vector ), intent ( inout ) :: self real ( real64 ), dimension ( self % dim ), intent ( in ) :: array self % v = array ! Copy the contents of array into self end subroutine elemental subroutine vector_from_vector ( self , v1 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v1 self % dim = v1 % dim self % v = v1 % v ! Copy the array contents end subroutine !=============================================================================! !=                            State Functions                                =! !=============================================================================! elemental function vector_conform ( self , v2 ) result ( bool ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 logical :: bool bool = ( self % dim == v2 % dim ) end function elemental function vector_is_orthogonal ( self , v2 , eps ) result ( bool ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ), intent ( in ), optional :: eps logical :: bool if ( present ( eps )) then bool = abs ( self . dot . v2 ) < eps else bool = abs ( self . dot . v2 ) < vector_epsilon end if end function elemental function vector_is_normal ( self ) result ( bool ) class ( vector ), intent ( in ) :: self logical :: bool if ( self % length () - 1 < vector_epsilon ) then bool = . true . else bool = . false . end if end function elemental function vector_is_allocated ( self ) result ( bool ) class ( vector ), intent ( in ) :: self logical :: bool if ( allocated ( self % v )) then bool = . true . else bool = . false . end if end function !=============================================================================! !=                            Print Functions                                =! !=============================================================================! subroutine vector_print_info ( self ) class ( vector ), intent ( in ) :: self if (. not . self % allocated ()) then write ( * , * ) \"Vector not allocated\" else write ( * , * ) \"dimension: \" , self % dim write ( * , * ) \"data: \" , self % v write ( * , * ) \"allocated: \" , self % allocated () end if end subroutine subroutine vector_print_coordinates ( self ) class ( vector ), intent ( in ) :: self print * , self % v end subroutine !=============================================================================! !=                           Access Functions                                =! !=============================================================================! elemental function vector_at_index ( self , index ) result ( x_n ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: index real ( real64 ) :: x_n if ( index > self % dim ) error stop \"out of bounds error\" x_n = self % v ( index ) end function elemental subroutine vector_set_index_int ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index integer , intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r32 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real32 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r64 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real64 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = val end subroutine pure function vector_as_array ( self ) result ( array ) class ( vector ), intent ( in ) :: self real ( real64 ), dimension ( self % dim ) :: array array = self % v end function !=============================================================================! !=                             Norm Functions                                =! !=============================================================================! elemental function vector_euclidiean_norm ( self ) result ( length ) class ( vector ), intent ( in ) :: self real ( real64 ) :: length length = self % pnorm ( 2 ) end function elemental function vector_pnorm ( self , p ) result ( pnorm ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: p real ( real64 ) :: power , pnorm if ( p < 1 ) error stop \"P-norm must be greater than or equal to 1\" power = 1._real64 / p pnorm = sum ( self % v ** p ) ** power end function elemental function vector_normalize ( self ) result ( normalized_vector ) !! Normalize a vector such that its euclidian norm is 1 class ( vector ), intent ( in ) :: self type ( vector ) :: normalized_vector real ( real64 ) :: norm norm = self % length () normalized_vector = ( self / norm ) end function !=============================================================================! !=                            Operator Functions                             =! !=============================================================================! elemental function vector_dot_vector ( self , v2 ) result ( inner_product ) !! Calculate the inner product of two vectors class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ) :: inner_product if ( self % conform_ ( v2 )) then inner_product = sum ( self % v * v2 % v ) else error stop \"Cannot take the inner product of nonconforming vectors\" end if end function elemental function vector_proj_vector ( self , v2 ) result ( v3 ) !! Project vector self ONTO v2 proj_v2(self) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 real ( real64 ) :: scalar scalar = ( self . dot . v2 ) / ( v2 . dot . v2 ) v3 = v2 * scalar ! Allocate the space for a new vector end function elemental function vector_plus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new ( self % dim ) v3 % v = self % v ! + v2%v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_minus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new ( self % dim ) v3 % v = self % v - v2 % v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_times_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_div_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new ( self % dim ) v2 % v = self % v / scalar end function !=============================================================================! !=                           Static Functions                                =! !=============================================================================! elemental subroutine vector_zero ( self , dim ) class ( vector ), intent ( inout ) :: self integer , intent ( in ), optional :: dim if ( present ( dim )) then call self % new ( dim ) else call self % new () end if self % v = 0 end subroutine !=============================================================================! !=                                Destructor                                 =! !=============================================================================! subroutine vector_destructor ( self ) type ( vector ), intent ( inout ) :: self write ( * , * ) \"vector_destructor called\" if ( self % allocated ()) then print * , \"deallocating fields\" deallocate ( self % v ) end if end subroutine !=============================================================================! !=                              Gram-Schmidt                                 =! !=============================================================================! function gram_schmidt ( vector_array ) result ( ortho ) class ( vector ), dimension (:) :: vector_array type ( vector ), dimension (:), allocatable :: ortho integer i , j , k , n n = vector_array ( 1 )% dim k = size ( vector_array ) allocate ( ortho ( k )) call ortho % zero ( n ) print * , \"dimension of input basis = \" , vector_array ( 1 )% dim print * , \"number of basis vectors = \" , size ( vector_array ) print * , \"orthonormal_basis set to 0\" ortho ( 1 ) = vector_array ( 1 )% normalize () do i = 2 , k ortho ( i ) = vector_array ( i ) do j = 1 , i - 1 ortho ( i ) = ortho ( i ) - ( ortho ( i ) . proj . ortho ( j )) end do ortho ( i ) = ortho ( i )% normalize () end do end function subroutine print_basis ( basis ) class ( vector ), dimension (:), intent ( in ) :: basis integer :: i , k k = size ( basis ) do i = 1 , k call basis ( i )% print () end do end subroutine function is_orthonormal ( basis ) result ( bool ) class ( vector ), dimension (:), intent ( in ) :: basis logical :: bool integer :: k , i , j k = size ( basis ) if ( all ( basis % is_normal ())) then do i = 1 , k do j = i + 1 , k if (. not . basis ( i )% is_ortho ( basis ( j ))) then bool = . false . return end if end do end do bool = . true . else bool = . false . end if end function end module","tags":"","loc":"sourcefile/vector.f90.html"},{"title":"matrix.f90 â€“ Fortran Program","text":"Contents Modules matrix_m Source Code matrix.f90 Source Code module matrix_m !! A matrix is a wrapper class for a rank 1 array of vector objects. <br> !! Matrices can be used to represent a variety of mathematical structures. This class is primarily used !! to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment !! of a rank2 array of any type, but the underlying data will be stored with double precision. <br> !! !!```fortran !!type(matrix) :: m, ortho_basis !! !!m = reshape([1, 2, 3, 4], [2, 2]) ! Create a 2x2 matrix !!print*, \"M: \" !!call m%print() !! !!ortho_basis = m%gram_schmidt() ! Compute an orthonormal basis using the Gram-Schmidt method !! !!print\"(A)\", \"Ortho:\" !!call ortho_basis%print()!! !!``` !! !!output: !! !!![test](../media/matrix_m_output.png) !! use vector_m use iso_fortran_env , only : real64 , real32 implicit none private type , public :: matrix private integer :: k = 1 !! The number of vectors integer :: n = 1 !! Dimension of vectors type ( vector ), dimension (:), pointer :: m !! The vectors stored in a matrix logical :: m_allocated = . false . contains private procedure , public :: new => new_matrix procedure , public :: clear => clear_matrix procedure , public :: print => print_matrix procedure , public :: vec => access_vector_matrix !! Get the kth vector in the matrix procedure , public :: at => at_index_matrix procedure , public :: gram_schmidt => gram_schmidt_matrix procedure , public :: is_orthonormal => is_orthonormal_matrix procedure , public :: as_array => matrix_as_array generic , public :: set => set_int_ , set_r32_ , set_r64_ generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_matrix procedure :: from_array_int_ => matrix_from_rank2_array_int procedure :: from_array_r32_ => matrix_from_rank2_array_r32 procedure :: from_array_r64_ => matrix_from_rank2_array_r64 procedure :: from_matrix => matrix_from_matrix procedure :: set_int_ => set_index_matrix_int procedure :: set_r32_ => set_index_matrix_r32 procedure :: set_r64_ => set_index_matrix_r64 procedure :: alloc_ => allocate_matrix_data procedure :: dealloc_ => deallocate_matrix_data end type contains elemental subroutine new_matrix ( self , n , k ) class ( matrix ), intent ( inout ) :: self integer , intent ( in ) :: n !! The dimension of each constituent vector integer , intent ( in ) :: k !! The number of vectors call self % clear () if ( k <= 0 . or . n <= 0 ) error stop \"Cannot instantiate vector with 0 or negative dimension\" self % k = k self % n = n call self % alloc_ () end subroutine pure subroutine matrix_from_rank2_array_int ( self , array ) class ( matrix ), intent ( inout ) :: self integer , dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r32 ( self , array ) class ( matrix ), intent ( inout ) :: self real ( real32 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r64 ( self , array ) class ( matrix ), intent ( inout ) :: self real ( real64 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine elemental subroutine matrix_from_matrix ( self , m ) class ( matrix ), intent ( inout ) :: self class ( matrix ), intent ( in ) :: m integer :: i self % n = m % n self % k = m % k call self % new ( m % n , m % k ) do i = 1 , self % k self % m ( i ) = m % vec ( i ) end do end subroutine elemental subroutine clear_matrix ( self ) class ( matrix ), intent ( inout ) :: self self % k = 0 self % n = 0 if ( self % m_allocated ) then call self % dealloc_ () end if end subroutine elemental subroutine allocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr allocate ( self % m ( self % k ), STAT = ierr ) call self % m % zero ( self % n ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . true . end subroutine elemental subroutine deallocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr call self % m % dealloc_ () deallocate ( self % m , STAT = ierr ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . false . end subroutine subroutine print_matrix ( self ) class ( matrix ), intent ( in ) :: self character ( 10 ) :: num_fmt character ( 100 ) :: fmt integer :: i , j write ( num_fmt , \"(I0)\" ) self % k fmt = \"(\" // num_fmt // \"(G11.5, 2X))\" ! fmt = \"(\" // num_fmt // \"(G0, 2X))\" do i = 1 , self % n print fmt , ( self % at ( i , j ), j = 1 , self % k ) end do end subroutine elemental function at_index_matrix ( self , i , j ) result ( element ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ) :: element element = self % m ( j )% at ( i ) end function subroutine set_index_matrix_int ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector integer , intent ( in ) :: x call self % m ( j )% set ( i , x ) end subroutine subroutine set_index_matrix_r32 ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real32 ) :: x call self % m ( j )% set ( i , x ) end subroutine subroutine set_index_matrix_r64 ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ) :: x call self % m ( j )% set ( i , x ) end subroutine elemental function access_vector_matrix ( self , v ) result ( vec ) !! Get a copy of the vth vector class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: v type ( vector ) :: vec if ( v < 1 . or . v > self % k ) error stop \"Out of bounds index\" vec = self % m ( v ) end function elemental function gram_schmidt_matrix ( self ) result ( ortho ) class ( matrix ), intent ( in ) :: self type ( matrix ) :: ortho integer i , j , n , k n = self % n k = self % k if ( k > n ) k = n !! If there are more vectors than the dimension of the vector, only output n vectors call ortho % new ( n , k ) ! print *, \"dimension of input basis = \", self%n ! print *, \"number of basis vectors = \", self%k ! print *, \"orthonormal_basis set to 0\" ortho % m ( 1 ) = self % m ( 1 )% normalize () do i = 2 , k ortho % m ( i ) = self % m ( i ) do j = 1 , i - 1 ortho % m ( i ) = ortho % m ( i ) - ( ortho % m ( i ) . proj . ortho % m ( j )) ! ortho%m(i) = (ortho%m(i) .proj. ortho%m(j)) - ortho%m(i) end do ortho % m ( i ) = ortho % m ( i )% normalize () end do end function elemental function is_orthonormal_matrix ( self ) result ( bool ) class ( matrix ), intent ( in ) :: self logical :: bool integer :: k , i , j if ( all ( self % m % is_normal ())) then do i = 1 , k do j = i + 1 , k if (. not . self % m ( i )% is_ortho ( self % m ( j ))) then bool = . false . return end if end do end do bool = . true . else bool = . false . end if end function pure function matrix_as_array ( self ) result ( array ) class ( matrix ), intent ( in ) :: self real ( real64 ), dimension ( self % n , self % k ) :: array integer :: i forall ( i = 1 : self % k ) array ( i ,:) = self % m ( i )% as_array () end forall end function end module","tags":"","loc":"sourcefile/matrix.f90.html"},{"title":"gs_test_2.f90 â€“ Fortran Program","text":"Contents Programs gs_test_2 Source Code gs_test_2.f90 Source Code program gs_test_2 use iso_fortran_env use matrix_m use vector_m implicit none type ( matrix ) :: m , ortho m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) print * , \"M: \" call m % print () ortho = m % gram_schmidt () print \"(A)\" , \"Ortho: \" call ortho % print () end program","tags":"","loc":"sourcefile/gs_test_2.f90.html"},{"title":"vector â€“ Fortran Program ","text":"type, public :: vector Contents Constructor vector Finalization Procedures vector_destructor Type-Bound Procedures new new_ clear print_info print at set length pnorm normalize is_ortho is_normal as_array zero allocated alloc_ dealloc_ assignment(=) operator(.dot.) operator(.proj.) operator(*) operator(/) operator(+) operator(-) Constructor public interface vector private pure function vector_constructor_int(array) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r32(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r64(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value type( vector ) private elemental function vector_constructor_dim(dim) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value type( vector ) Finalization Procedures final :: vector_destructor private subroutine vector_destructor(self) Arguments Type Intent Optional Attributes Name type( vector ), intent(inout) :: self Type-Bound Procedures procedure, public :: new => new_vector private elemental subroutine new_vector(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), optional :: dim procedure, public :: new_ => new_constructor private pure subroutine new_constructor(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: dim procedure, public :: clear => clear_vector Deallocate the data, set v_allocated to false, set dim to 0 private elemental subroutine clear_vector(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public :: print_info => vector_print_info private subroutine vector_print_info(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: print => vector_print_coordinates private subroutine vector_print_coordinates(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: at => vector_at_index private elemental function vector_at_index(self, index) result(x_n) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: index Return Value real(kind=real64) generic, public :: set => set_int_, set_r32_, set_r64_ private elemental subroutine vector_set_index_int(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index integer, intent(in) :: val private elemental subroutine vector_set_index_r32(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real32), intent(in) :: val private elemental subroutine vector_set_index_r64(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real64), intent(in) :: val procedure, public :: length => vector_euclidiean_norm private elemental function vector_euclidiean_norm(self) result(length) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64) procedure, public :: pnorm => vector_pnorm private elemental function vector_pnorm(self, p) result(pnorm) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: p Return Value real(kind=real64) procedure, public :: normalize => vector_normalize private elemental function vector_normalize(self) result(normalized_vector) Normalize a vector such that its euclidian norm is 1 Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value type( vector ) procedure, public :: is_ortho => vector_is_orthogonal private elemental function vector_is_orthogonal(self, v2, eps) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 real(kind=real64), intent(in), optional :: eps Return Value logical procedure, public :: is_normal => vector_is_normal private elemental function vector_is_normal(self) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: as_array => vector_as_array private pure function vector_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%dim) procedure, public :: zero => vector_zero private elemental subroutine vector_zero(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), optional :: dim procedure, public :: allocated => vector_is_allocated private elemental function vector_is_allocated(self) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: alloc_ => allocate_vector_data private elemental subroutine allocate_vector_data(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public :: dealloc_ => deallocate_vector_data public elemental subroutine deallocate_vector_data (self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_vector_ private pure subroutine vector_from_array_int(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), dimension(self%dim) :: array private pure subroutine vector_from_array_r32(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in), dimension(self%dim) :: array private pure subroutine vector_from_array_r64(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in), dimension(self%dim) :: array private elemental subroutine vector_from_vector(self, v1) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v1 generic, public :: operator(.dot.) => dot_ private elemental function vector_dot_vector(self, v2) result(inner_product) Calculate the inner product of two vectors Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.proj.) => proj_ private elemental function vector_proj_vector(self, v2) result(v3) Project vector self ONTO v2 proj_v2(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(*) => scalar_mult_int_, scalar_mult_r32_, scalar_mult_r64_ private elemental function vector_times_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) generic, public :: operator(/) => scalar_div_int_, scalar_div_r32_, scalar_div_r64_ private elemental function vector_div_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) generic, public :: operator(+) => plus_ private elemental function vector_plus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(-) => minus_ private elemental function vector_minus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector )","tags":"","loc":"type/vector.html"},{"title":"nd_vector â€“ Fortran Program ","text":"type, public :: nd_vector Contents Variables n data Components Type Visibility Attributes Name Initial integer, public, len :: n = 3 real(kind=real64), public, dimension(n) :: data","tags":"","loc":"type/nd_vector.html"},{"title":"matrix â€“ Fortran Program ","text":"type, public :: matrix Contents Type-Bound Procedures new clear print vec at gram_schmidt is_orthonormal as_array set assignment(=) Type-Bound Procedures procedure, public :: new => new_matrix private elemental subroutine new_matrix(self, n, k) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in) :: n The dimension of each constituent vector integer, intent(in) :: k The number of vectors procedure, public :: clear => clear_matrix private elemental subroutine clear_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self procedure, public :: print => print_matrix private subroutine print_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix private elemental function access_vector_matrix(self, v) result(vec) Get a copy of the vth vector Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: v Return Value type( vector ) procedure, public :: at => at_index_matrix private elemental function at_index_matrix(self, i, j) result(element) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector Return Value real(kind=real64) procedure, public :: gram_schmidt => gram_schmidt_matrix private elemental function gram_schmidt_matrix(self) result(ortho) If there are more vectors than the dimension of the vector, only output n vectors Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value type( matrix ) procedure, public :: is_orthonormal => is_orthonormal_matrix private elemental function is_orthonormal_matrix(self) result(bool) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value logical procedure, public :: as_array => matrix_as_array private pure function matrix_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%n, self%k) generic, public :: set => set_int_, set_r32_, set_r64_ private subroutine set_index_matrix_int(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector integer, intent(in) :: x private subroutine set_index_matrix_r32(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real32) :: x private subroutine set_index_matrix_r64(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real64) :: x generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix private pure subroutine matrix_from_rank2_array_int(self, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r32(self, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real32), intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r64(self, array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real64), intent(in), dimension(:,:) :: array private elemental subroutine matrix_from_matrix(self, m) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self class( matrix ), intent(in) :: m","tags":"","loc":"type/matrix.html"},{"title":"gram_schmidt â€“ Fortran Program","text":"public function gram_schmidt(vector_array) result(ortho) Arguments Type Intent Optional Attributes Name class( vector ), dimension(:) :: vector_array Return Value type( vector ),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/gram_schmidt.html"},{"title":"is_orthonormal â€“ Fortran Program","text":"public function is_orthonormal(basis) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in), dimension(:) :: basis Return Value logical Contents None","tags":"","loc":"proc/is_orthonormal.html"},{"title":"nd_test â€“ Fortran Program","text":"public subroutine nd_test(nd) Arguments Type Intent Optional Attributes Name class( nd_vector n=*), intent(in) :: nd Contents None","tags":"","loc":"proc/nd_test.html"},{"title":"deallocate_vector_data â€“ Fortran Program","text":"public elemental subroutine deallocate_vector_data(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Contents None","tags":"","loc":"proc/deallocate_vector_data.html"},{"title":"print_basis â€“ Fortran Program","text":"public subroutine print_basis(basis) Arguments Type Intent Optional Attributes Name class( vector ), intent(in), dimension(:) :: basis Contents None","tags":"","loc":"proc/print_basis.html"},{"title":"vector â€“ Fortran Program","text":"public interface vector Contents Module Procedures vector_constructor_int vector_constructor_r32 vector_constructor_r64 vector_constructor_dim Module Procedures private pure function vector_constructor_int(array) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r32(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r64(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value type( vector ) private elemental function vector_constructor_dim(dim) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value type( vector )","tags":"","loc":"interface/vector.html"},{"title":"vector_m â€“ Fortran Program","text":"Attempt to play around with a vector object A vector has the following operations: Addition with another vector\n Multiplication with a scalar \n Inner product\n Norm (which norm?)\n Projection of a onto b The internal representaion of a vector is an array of fixed size, pointed to by a pointer.\n This way we can use the fundamental data of an array within our specific class Uses iso_fortran_env Contents Interfaces vector Derived Types vector nd_vector Functions gram_schmidt is_orthonormal Subroutines nd_test deallocate_vector_data print_basis Interfaces public interface vector private pure function vector_constructor_int(array) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r32(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value type( vector ) private pure function vector_constructor_r64(array) result(this) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value type( vector ) private elemental function vector_constructor_dim(dim) result(this) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value type( vector ) Derived Types type, public :: vector Constructor private pure function vector_constructor_int (array) private pure function vector_constructor_r32 (array) private pure function vector_constructor_r64 (array) private elemental function vector_constructor_dim (dim) Finalizations Procedures final :: vector_destructor","tags":"","loc":"module/vector_m.html"},{"title":"matrix_m â€“ Fortran Program","text":"A matrix is a wrapper class for a rank 1 array of vector objects. Matrices can be used to represent a variety of mathematical structures. This class is primarily used\n to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment \n of a rank2 array of any type, but the underlying data will be stored with double precision. type ( matrix ) :: m , ortho_basis m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) ! Create a 2x2 matrix print * , \"M: \" call m % print () ortho_basis = m % gram_schmidt () ! Compute an orthonormal basis using the Gram-Schmidt method print \"(A)\" , \"Ortho:\" call ortho_basis % print () !! output: Uses vector_m iso_fortran_env Contents Derived Types matrix Derived Types type, public :: matrix Type-Bound Procedures procedure, public :: new => new_matrix procedure, public :: clear => clear_matrix procedure, public :: print => print_matrix procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix procedure, public :: at => at_index_matrix procedure, public :: gram_schmidt => gram_schmidt_matrix procedure, public :: is_orthonormal => is_orthonormal_matrix procedure, public :: as_array => matrix_as_array generic, public :: set => set_int_, set_r32_, set_r64_ generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix","tags":"","loc":"module/matrix_m.html"},{"title":"gs_test_2 â€“ Fortran Program","text":"Uses iso_fortran_env matrix_m vector_m Contents Variables m ortho Variables Type Attributes Name Initial type( matrix ) :: m type( matrix ) :: ortho","tags":"","loc":"program/gs_test_2.html"}]}