var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is ejovo13. This is for Formath Note This Library is a work in process and is the process of me learning how to implement fundamental numerical algorithms from the ground up. This package is currently configured to my system, as it is intended principally as a learning experience. Developer Info Evan Voyles Learning Fortran by writing Fortran","tags":"home","loc":"index.html"},{"title":"vector.f90 – Fortran Program","text":"Contents Modules vector_m Source Code vector.f90 Source Code module vector_m !! Attempt to play around with a vector object !! A vector, v has the following operations: !! !! Addition with another vector !! Multiplication with a scalar !! Inner product !! Norm (which norm?) !! Projection of a onto b !! !! !! The internal representaion of a vector is an array of fixed size, pointed to by a pointer. !! This way we can use the fundamental data of an array within our specific class use iso_fortran_env , only : real64 , real32 , int32 , int64 implicit none private public :: print_basis , gram_schmidt , is_orthonormal , deallocate_vector_data , operator ( * ), operator ( / ) real ( real64 ), parameter :: vector_epsilon = 1 d - 14 type , public :: vector private real ( real64 ), dimension (:), allocatable :: v integer :: dim = 0 contains private procedure , public :: size => vector_size !! Return the number of elements of the currently allocated vector procedure , public :: clear => clear_vector !! Deallocate the data, set dim to 0 procedure , public :: print_info => vector_print_info !! Print diagnostic information about the vector procedure , public :: print => vector_print_coordinates !! Print only the data stored in the vector object as a row vector procedure , public :: at => vector_at_index !! Return the element x_i generic , public :: set => set_int_ , set_r32_ , set_r64_ !! Set the value of the element x_i at index i procedure , public :: length => vector_euclidiean_norm !! Calculate the euclidean norm of a vector v procedure , public :: pnorm => vector_pnorm !! Calculate the pnorm of a vector v procedure , public :: normalize => vector_normalize !! Normalize the elements of the passed vector v !! Normaliz**e** is a **subroutine** such that it alters the elements of the passed vector v to avoid costs of copying involved with a function procedure , public :: normalized => vector_normalized !! Return a normalized vector n pointing in the same direction as v !!@Note !! The function normaliz**ed** is a **function** such that it returns a normalized version of the passed vector v procedure , public :: orthogonalize => vector_orthogonalize !! Orthogonalize a vector v against a passed **normalized** vector n !!@Note !!A future version may just check if the passed vector is normalized by testing a \"normalized\" logical type that will be stored in a vector. procedure , public :: orthogonalized => vector_orthogonalized !! Return a vector v that is orthogonalized against a passed **normalized** vector n !!@Note !! This is a function that returns a new vector v procedure , public :: orthonormalize => vector_orthonormalize !! Orthogonalize and normalize a vector v against a passed **normalized** vector n !!@Note !! This is a subroutine that modifies the passed vector v procedure , public :: orthonormalized => vector_orthonormalized !! Return an orthogonalized and normalized vector v against a passed **normalized** vector n !!@Note !! This is a function that returns a new vector v procedure , public :: householder_transform => vector_householder_sub !! Rotate a passed vector v about the hyper plane described by the passed **normalized** vector n !!@Note !! This is a subroutine that modifies the passed vector procedure , public :: eye => vector_constructor_eye procedure , public :: is_ortho => vector_is_orthogonal procedure , public :: is_normal => vector_is_normal procedure , public :: data => vector_as_array procedure , public :: zero => vector_zero procedure , public :: allocated => vector_is_allocated procedure , public :: alloc_ => allocate_vector_data procedure , public :: dealloc_ => deallocate_vector_data procedure :: new_ => new_constructor procedure :: dot_ => vector_dot_vector procedure :: proj_ => vector_proj_vector procedure :: outer_ => vector_outer_vector procedure :: householder_ => vector_householder procedure :: conform_ => vector_conform procedure :: scalar_mult_int_ => vector_times_scalar_int procedure :: scalar_mult_r32_ => vector_times_scalar_r32 procedure :: scalar_mult_r64_ => vector_times_scalar_r64 procedure :: scalar_div_int_ => vector_div_scalar_int procedure :: scalar_div_r32_ => vector_div_scalar_r32 procedure :: scalar_div_r64_ => vector_div_scalar_r64 procedure :: set_int_ => vector_set_index_int procedure :: set_r32_ => vector_set_index_r32 procedure :: set_r64_ => vector_set_index_r64 procedure :: minus_ => vector_minus_vector procedure :: unary_minus_ => vector_unary_minus procedure :: plus_ => vector_plus_vector !===============Operators Functions==================! generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_vector_ , from_int_ , & from_r32_ , from_r64_ generic , public :: operator (. dot .) => dot_ generic , public :: operator (. inner .) => dot_ generic , public :: operator (. outer .) => outer_ generic , public :: operator (. proj .) => proj_ generic , public :: operator (. householder .) => householder_ generic , public :: operator ( * ) => scalar_mult_int_ , scalar_mult_r32_ , scalar_mult_r64_ , times_vec_ generic , public :: operator ( / ) => scalar_div_int_ , scalar_div_r32_ , scalar_div_r64_ , div_vec_ generic , public :: operator ( + ) => plus_ generic , public :: operator ( - ) => minus_ , unary_minus_ !===============Operator Subroutines==================! ! The point of an operator subroutine is to alter the passed object. This cuts down on copying ! the data between functions generic , public :: times => times_int_sub_ , times_r32_sub_ , times_r64_sub_ , times_vec_sub_ generic , public :: div => div_int_sub_ , div_r32_sub_ , div_r64_sub_ , div_vec_sub_ generic , public :: proj => project_onto_sub_ generic , public :: plus => plus_vector_sub_ generic , public :: minus => minus_vector_sub_ procedure :: times_int_sub_ => vector_times_scalar_int_sub procedure :: times_r32_sub_ => vector_times_scalar_r32_sub procedure :: times_r64_sub_ => vector_times_scalar_r64_sub procedure :: times_vec_sub_ => vector_times_vector_sub procedure :: div_int_sub_ => vector_div_scalar_int_sub procedure :: div_r32_sub_ => vector_div_scalar_r32_sub procedure :: div_r64_sub_ => vector_div_scalar_r64_sub procedure :: div_vec_sub_ => vector_div_vector_sub procedure :: project_onto_sub_ => vector_proj_vector_sub procedure :: plus_vector_sub_ => vector_plus_vector_sub procedure :: minus_vector_sub_ => vector_minus_vector_sub procedure :: from_int_ => vector_from_int procedure :: from_r32_ => vector_from_r32 procedure :: from_r64_ => vector_from_r64 procedure :: from_array_int_ => vector_from_array_int procedure :: from_array_r32_ => vector_from_array_r32 procedure :: from_array_r64_ => vector_from_array_r64 procedure :: from_vector_ => vector_from_vector procedure :: times_vec_ => vector_times_vector procedure :: div_vec_ => vector_div_vector final :: vector_destructor end type interface vector !! Construct a vector object procedure :: vector_constructor_int !! Construct a procedure :: vector_constructor_r32 procedure :: vector_constructor_r64 procedure :: vector_constructor_dim procedure :: vector_constructor_dim_value_int procedure :: vector_constructor_dim_value_r32 procedure :: vector_constructor_dim_value_r64 procedure :: vector_constructor_vector end interface interface operator ( * ) procedure :: int_times_vector procedure :: r32_times_vector procedure :: r64_times_vector end interface interface operator ( / ) procedure :: int_div_vector procedure :: r32_div_vector procedure :: r64_div_vector end interface contains !=============================================================================! !=                               Constructors                                =! !=============================================================================! pure subroutine new_constructor ( self , dim ) !! allocate the proper space for the elements of vector v and set the dimension to dim class ( vector ), intent ( inout ) :: self !! v integer , intent ( in ) :: dim !! n self % dim = dim allocate ( self % v ( dim )) end subroutine pure function vector_constructor_int ( array ) result ( this ) !! Construct a vector v from an array of integers integer , dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function pure function vector_constructor_r32 ( array ) result ( this ) !! Construct a vector v from an array of single precision reals real ( real32 ), dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function pure function vector_constructor_r64 ( array ) result ( this ) !! Construct a vector v from an array of double precision reals real ( real64 ), dimension (:), intent ( in ) :: array !! input data type ( vector ) :: this !! v call this % new_ ( size ( array )) this % v = array end function elemental function vector_constructor_dim ( dim ) result ( this ) !! Construct a vector by declaring its size !! Allocate an n-dimensional vector and fill its values with 0 integer , intent ( in ) :: dim !! n type ( vector ) :: this !! v call this % new_ ( dim ) this % v = 0 end function elemental function vector_constructor_dim_value_int ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with integer val integer , intent ( in ) :: dim !! n integer , intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_dim_value_r32 ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with single precision real val integer , intent ( in ) :: dim !! n real ( real32 ), intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_dim_value_r64 ( dim , val ) result ( this ) !! Construct a vector v of dimension n and fill its values with double precision real val integer , intent ( in ) :: dim !! n real ( real64 ), intent ( in ) :: val !! val type ( vector ) :: this !! v call this % new_ ( dim ) this % v = val end function elemental function vector_constructor_vector ( v1 ) result ( v2 ) !! Construct a vector from another vector !! @Note !!Not very efficient due do the multiple copies that occur (About three times slower than assigment) class ( vector ), intent ( in ) :: v1 type ( vector ) :: v2 v2 = v1 end function elemental function vector_constructor_eye ( self , dim ) result ( v2 ) !! Construct a vector v that is equal to the dimth column of the Identity matrix I_{dim} class ( vector ), intent ( in ) :: self !! v integer , intent ( in ), optional :: dim type ( vector ) :: v2 if ( present ( dim )) then v2 = vector ( dim , 0 ) call v2 % set ( dim , 1 ) else v2 = vector ( self % dim , 0 ) call v2 % set ( self % dim , 1 ) end if end function elemental subroutine clear_vector ( self ) !! class ( vector ), intent ( inout ) :: self if ( self % allocated ()) then call self % dealloc_ () else self % dim = 0 end if end subroutine elemental subroutine allocate_vector_data ( self , dim ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: dim integer :: ierr allocate ( self % v ( dim ), STAT = ierr ) self % dim = dim if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine elemental subroutine deallocate_vector_data ( self ) class ( vector ), intent ( inout ) :: self integer :: ierr deallocate ( self % v , STAT = ierr ) self % dim = 0 if ( ierr /= 0 ) error stop \"Error allocating vector\" end subroutine !=============================================================================! !=                         Assigment Functions                               =! !=============================================================================! pure subroutine vector_from_int ( self , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: val if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_r32 ( self , val ) class ( vector ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: val if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_r64 ( self , val ) class ( vector ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: val if ( self % allocated ()) then self % v = val ! Copy the contents of array into self else self = vector ( 1 , val ) end if end subroutine pure subroutine vector_from_array_int ( self , array ) class ( vector ), intent ( inout ) :: self integer , dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r32 ( self , array ) class ( vector ), intent ( inout ) :: self real ( real32 ), dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine pure subroutine vector_from_array_r64 ( self , array ) class ( vector ), intent ( inout ) :: self real ( real64 ), dimension (:), intent ( in ) :: array self % dim = size ( array ) self % v = array ! Copy the contents of array into self end subroutine elemental subroutine vector_from_vector ( self , v1 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v1 self % dim = v1 % dim self % v = v1 % v ! Copy the array contents end subroutine !=============================================================================! !=                            State Functions                                =! !=============================================================================! elemental function vector_conform ( self , v2 ) result ( bool ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 logical :: bool bool = ( self % dim == v2 % dim ) end function elemental function vector_is_orthogonal ( self , v2 , eps ) result ( bool ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ), intent ( in ), optional :: eps logical :: bool if ( present ( eps )) then bool = abs ( self . dot . v2 ) < eps else bool = abs ( self . dot . v2 ) < vector_epsilon end if end function elemental function vector_is_normal ( self ) result ( bool ) class ( vector ), intent ( in ) :: self logical :: bool if ( self % length () - 1 < vector_epsilon ) then bool = . true . else bool = . false . end if end function elemental function vector_is_allocated ( self ) result ( bool ) class ( vector ), intent ( in ) :: self logical :: bool if ( allocated ( self % v )) then bool = . true . else bool = . false . end if end function elemental function vector_size ( self ) result ( n ) class ( vector ), intent ( in ) :: self integer :: n n = self % dim end function !=============================================================================! !=                            Print Functions                                =! !=============================================================================! subroutine vector_print_info ( self ) class ( vector ), intent ( in ) :: self if (. not . self % allocated ()) then write ( * , * ) \"Vector not allocated\" else write ( * , * ) \"dimension: \" , self % dim write ( * , * ) \"data: \" , self % v write ( * , * ) \"allocated: \" , self % allocated () end if end subroutine subroutine vector_print_coordinates ( self ) class ( vector ), intent ( in ) :: self print * , self % v end subroutine !=============================================================================! !=                           Access Functions                                =! !=============================================================================! elemental function vector_at_index ( self , index ) result ( x_n ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: index real ( real64 ) :: x_n if ( index > self % dim ) error stop \"out of bounds error\" x_n = self % v ( index ) end function elemental subroutine vector_set_index_int ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index integer , intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r32 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real32 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = real ( val , real64 ) end subroutine elemental subroutine vector_set_index_r64 ( self , index , val ) class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: index real ( real64 ), intent ( in ) :: val if ( index > self % dim ) error stop \"out of bounds error\" self % v ( index ) = val end subroutine pure function vector_as_array ( self ) result ( array ) class ( vector ), intent ( in ) :: self real ( real64 ), dimension ( self % dim ) :: array array = self % v end function !=============================================================================! !=                             Norm Functions                                =! !=============================================================================! elemental function vector_euclidiean_norm ( self ) result ( length ) class ( vector ), intent ( in ) :: self real ( real64 ) :: length length = self % pnorm ( 2 ) end function elemental function vector_pnorm ( self , p ) result ( pnorm ) class ( vector ), intent ( in ) :: self integer , intent ( in ) :: p real ( real64 ) :: power , pnorm if ( p < 1 ) error stop \"P-norm must be greater than or equal to 1\" power = 1._real64 / p pnorm = sum ( self % v ** p ) ** power end function elemental subroutine vector_normalize ( self ) !! Normalize a vector such that its euclidian norm is 1 class ( vector ), intent ( inout ) :: self real ( real64 ) :: norm norm = self % length () self % v = self % v / norm end subroutine elemental subroutine vector_orthogonalize ( self , v2 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: self_copy self_copy = self call self % proj ( v2 ) call self % minus ( self_copy ) end subroutine elemental subroutine vector_orthonormalize ( self , v2 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 call self % orthogonalize ( v2 ) call self % normalize () end subroutine elemental function vector_normalized ( self ) result ( normalized_vector ) !! Normalize a vector such that its euclidian norm is 1 class ( vector ), intent ( in ) :: self type ( vector ) :: normalized_vector real ( real64 ) :: norm norm = self % length () normalized_vector = ( self / norm ) end function elemental function vector_orthogonalized ( self , v2 ) result ( v3 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 v3 = self . proj . v2 v3 = self - v3 end function elemental function vector_orthonormalized ( self , v2 ) result ( v3 ) !! Orthogonalize a vector with respect to another class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 v3 = self % orthogonalized ( v2 ) call v3 % normalize () end function !=============================================================================! !=                            Operator Functions                             =! !=============================================================================! elemental function vector_dot_vector ( self , v2 ) result ( inner_product ) !! Calculate the inner product of two vectors class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ) :: inner_product if ( self % conform_ ( v2 )) then inner_product = sum ( self % v * v2 % v ) else error stop \"Cannot take the inner product of nonconforming vectors\" end if end function elemental function vector_proj_vector ( self , v2 ) result ( v3 ) !! Project vector self ONTO v2 proj_v2(self) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 real ( real64 ) :: scalar scalar = ( self . dot . v2 ) / ( v2 . dot . v2 ) v3 = v2 * scalar ! Allocate the space for a new vector end function pure function vector_outer_vector ( self , v2 ) result ( array ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ), dimension ( self % dim , v2 % dim ) :: array end function elemental function vector_householder ( self , normal ) result ( rotated ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: normal !! MUST BE A UNIT VECTOR type ( vector ) :: rotated rotated = self - ( 2 * ( self . inner . normal ) * normal ) end function elemental function vector_plus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new_ ( self % dim ) v3 % v = self % v + v2 % v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_minus_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if ( self % conform_ ( v2 )) then call v3 % new_ ( self % dim ) v3 % v = self % v - v2 % v else error stop \"Cannot add nonconforming vectors\" end if end function elemental function vector_times_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v * scalar end function elemental function vector_times_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" v3 = self % v * v2 % v end function elemental function vector_div_vector ( self , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: self class ( vector ), intent ( in ) :: v2 type ( vector ) :: v3 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" v3 = self % v / v2 % v end function elemental function vector_div_scalar_int ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self integer , intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r32 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real32 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function vector_div_scalar_r64 ( self , scalar ) result ( v2 ) !! Multiply a vector times an integer scalar class ( vector ), intent ( in ) :: self real ( real64 ), intent ( in ) :: scalar type ( vector ) :: v2 call v2 % new_ ( self % dim ) v2 % v = self % v / scalar end function elemental function int_times_vector ( scalar , vec ) result ( v2 ) integer , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function r32_times_vector ( scalar , vec ) result ( v2 ) real ( real32 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function r64_times_vector ( scalar , vec ) result ( v2 ) real ( real64 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * scalar end function elemental function int_div_vector ( scalar , vec ) result ( v2 ) integer , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function r32_div_vector ( scalar , vec ) result ( v2 ) real ( real32 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function r64_div_vector ( scalar , vec ) result ( v2 ) real ( real64 ), intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec type ( vector ) :: v2 v2 = vec * ( 1._real64 / scalar ) end function elemental function vector_unary_minus ( self ) result ( v2 ) class ( vector ), intent ( in ) :: self type ( vector ) :: v2 v2 = self * ( - 1 ) end function !=============================================================================! !=                         Operator Subroutines                              =! !=============================================================================! elemental subroutine vector_proj_vector_sub ( self , v2 ) !! Project vector self ONTO v2 proj_v2(self) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 real ( real64 ) :: scalar scalar = ( self . dot . v2 ) / ( v2 . dot . v2 ) self = v2 * scalar ! Allocate the space for a new vector end subroutine elemental subroutine vector_plus_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if ( self % conform_ ( v2 )) then self % v = self % v + v2 % v else error stop \"Cannot add nonconforming vectors\" end if end subroutine elemental subroutine vector_householder_sub ( self , normal ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: normal !! MUST BE A UNIT VECTOR call self % minus ( 2 * ( self . proj . normal )) end subroutine elemental subroutine vector_minus_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if ( self % conform_ ( v2 )) then self % v = self % v - v2 % v else error stop \"Cannot add nonconforming vectors\" end if end subroutine elemental subroutine vector_times_scalar_int_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_times_scalar_r32_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_times_scalar_r64_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: scalar self % v = self % v * scalar end subroutine elemental subroutine vector_div_scalar_int_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self integer , intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_div_scalar_r32_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real32 ), intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_div_scalar_r64_sub ( self , scalar ) !! Multiply a vector times an integer scalar class ( vector ), intent ( inout ) :: self real ( real64 ), intent ( in ) :: scalar self % v = self % v / scalar end subroutine elemental subroutine vector_unary_minus_sub ( self ) class ( vector ), intent ( inout ) :: self self % v = - self % v end subroutine elemental subroutine vector_times_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" self % v = self % v * v2 % v end subroutine elemental subroutine vector_div_vector_sub ( self , v2 ) class ( vector ), intent ( inout ) :: self class ( vector ), intent ( in ) :: v2 if (. not . self % conform_ ( v2 )) error stop \"Cannot multiply non_conforming vectors\" self % v = self % v / v2 % v end subroutine !=============================================================================! !=                           Static Functions                                =! !=============================================================================! elemental subroutine vector_zero ( self , dim ) class ( vector ), intent ( inout ) :: self integer , intent ( in ), optional :: dim if ( present ( dim )) then call self % new_ ( dim ) else call self % new_ ( 1 ) end if self % v = 0 end subroutine !=============================================================================! !=                                Destructor                                 =! !=============================================================================! subroutine vector_destructor ( self ) type ( vector ), intent ( inout ) :: self write ( * , * ) \"vector_destructor called\" if ( self % allocated ()) then print * , \"deallocating fields\" deallocate ( self % v ) end if end subroutine !=============================================================================! !=                              Gram-Schmidt                                 =! !=============================================================================! function gram_schmidt ( vector_array ) result ( ortho ) class ( vector ), dimension (:) :: vector_array type ( vector ), dimension (:), allocatable :: ortho integer i , j , k , n n = vector_array ( 1 )% dim k = size ( vector_array ) allocate ( ortho ( k )) call ortho % zero ( n ) print * , \"dimension of input basis = \" , vector_array ( 1 )% dim print * , \"number of basis vectors = \" , size ( vector_array ) print * , \"orthonormal_basis set to 0\" ortho ( 1 ) = vector_array ( 1 )% normalized () do i = 2 , k ortho ( i ) = vector_array ( i ) do j = 1 , i - 1 ortho ( i ) = ortho ( i ) - ( ortho ( i ) . proj . ortho ( j )) end do call ortho ( i )% normalize () end do end function subroutine print_basis ( basis ) class ( vector ), dimension (:), intent ( in ) :: basis integer :: i , k k = size ( basis ) do i = 1 , k call basis ( i )% print () end do end subroutine function is_orthonormal ( basis ) result ( bool ) class ( vector ), dimension (:), intent ( in ) :: basis logical :: bool integer :: k , i , j k = size ( basis ) if ( all ( basis % is_normal ())) then do i = 1 , k do j = i + 1 , k if (. not . basis ( i )% is_ortho ( basis ( j ))) then bool = . false . return end if end do end do bool = . true . else bool = . false . end if end function end module","tags":"","loc":"sourcefile/vector.f90.html"},{"title":"matrix.f90 – Fortran Program","text":"Contents Modules matrix_m Source Code matrix.f90 Source Code module matrix_m !! A matrix is a wrapper class for a rank 1 array of vector objects. <br> !! Matrices can be used to represent a variety of mathematical structures. This class is primarily used !! to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment !! of a rank2 array of any type, but the underlying data will be stored with double precision. <br> !! !!```fortran !!type(matrix) :: m, ortho_basis !! !!m = reshape([1, 2, 3, 4], [2, 2]) ! Create a 2x2 matrix !!print*, \"M: \" !!call m%print() !! !!ortho_basis = m%gram_schmidt() ! Compute an orthonormal basis using the Gram-Schmidt method !! !!print\"(A)\", \"Ortho:\" !!call ortho_basis%print()!! !!``` !! !!output: !! !!![test](../media/matrix_m_output.png) !! use vector_m use iso_fortran_env , only : real64 , real32 implicit none private type , public :: matrix private integer :: k = 1 !! Number of vectors integer :: n = 1 !! Dimension of vectors type ( vector ), dimension (:), pointer :: m !! The vectors stored in a matrix logical :: m_allocated = . false . !! Allocation status of pointer contains private procedure , public :: new => new_matrix !! Create a new matrix procedure , public :: clear => clear_matrix !! Clear all of the elements of a matrix procedure , public :: print => print_matrix !! Print the contents of a matrix procedure , public :: vec => access_vector_matrix !! Get the kth vector in the matrix procedure , public :: at => at_index_matrix !! Get the element at the index (i, j) procedure , public :: gram_schmidt => gram_schmidt_matrix !! Compute an otrthonormal basis for the vector space spanned by the columns of a matrix procedure , public :: is_orthonormal => is_orthonormal_matrix !! Check whether a matrix is orthonormal procedure , public :: as_array => matrix_as_array !! Return a rank2 Fortran array generic , public :: set => set_int_ , set_r32_ , set_r64_ !! Set the value of a_{i,j}) generic , public :: assignment ( = ) => from_array_int_ , from_array_r32_ , from_array_r64_ , from_matrix !! Assign the contents of a matrix from a rank2 Fortran array procedure :: from_array_int_ => matrix_from_rank2_array_int procedure :: from_array_r32_ => matrix_from_rank2_array_r32 procedure :: from_array_r64_ => matrix_from_rank2_array_r64 procedure :: from_matrix => matrix_from_matrix procedure :: set_int_ => set_index_matrix_int procedure :: set_r32_ => set_index_matrix_r32 procedure :: set_r64_ => set_index_matrix_r64 procedure :: alloc_ => allocate_matrix_data !! Allocate the space for an array containing the matrix's elements procedure :: dealloc_ => deallocate_matrix_data !! Deallocate the underlying container for a matrix's elements end type contains elemental subroutine new_matrix ( self , n , k ) !! Wipe the contents of a matrix and allocate the proper amount of space class ( matrix ), intent ( inout ) :: self !! Matrix object to wipe integer , intent ( in ) :: n !! Dimension of each constituent vector integer , intent ( in ) :: k !! Number of vectors call self % clear () if ( k <= 0 . or . n <= 0 ) error stop \"Cannot instantiate vector with 0 or negative dimension\" self % k = k self % n = n call self % alloc_ () end subroutine pure subroutine matrix_from_rank2_array_int ( self , array ) !! Assign a matrix from a rank2 integer array class ( matrix ), intent ( inout ) :: self integer , dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r32 ( self , array ) !! Assign a matrix from a rank2 single precision real array class ( matrix ), intent ( inout ) :: self real ( real32 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine pure subroutine matrix_from_rank2_array_r64 ( self , array ) !! Assign a matrix from a rank2 double precision array class ( matrix ), intent ( inout ) :: self real ( real64 ), dimension (:,:), intent ( in ) :: array integer :: i , k , n n = size ( array , dim = 1 ) k = size ( array , dim = 2 ) call self % new ( n , k ) do i = 1 , k self % m ( i ) = array (:, i ) end do end subroutine elemental subroutine matrix_from_matrix ( self , m ) !! class ( matrix ), intent ( inout ) :: self class ( matrix ), intent ( in ) :: m integer :: i self % n = m % n self % k = m % k call self % new ( m % n , m % k ) do i = 1 , self % k self % m ( i ) = m % vec ( i ) end do end subroutine elemental subroutine clear_matrix ( self ) class ( matrix ), intent ( inout ) :: self self % k = 0 self % n = 0 if ( self % m_allocated ) then call self % dealloc_ () end if end subroutine elemental subroutine allocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr allocate ( self % m ( self % k ), STAT = ierr ) call self % m % zero ( self % n ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . true . end subroutine elemental subroutine deallocate_matrix_data ( self ) class ( matrix ), intent ( inout ) :: self integer :: ierr call self % m % dealloc_ () deallocate ( self % m , STAT = ierr ) if ( ierr /= 0 ) error stop \"Error allocating vector\" self % m_allocated = . false . end subroutine subroutine print_matrix ( self ) class ( matrix ), intent ( in ) :: self character ( 10 ) :: num_fmt character ( 100 ) :: fmt integer :: i , j write ( num_fmt , \"(I0)\" ) self % k fmt = \"(\" // num_fmt // \"(G11.5, 2X))\" ! fmt = \"(\" // num_fmt // \"(G0, 2X))\" do i = 1 , self % n print fmt , ( self % at ( i , j ), j = 1 , self % k ) end do end subroutine elemental function at_index_matrix ( self , i , j ) result ( element ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ) :: element element = self % m ( j )% at ( i ) end function subroutine set_index_matrix_int ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector integer , intent ( in ) :: x call self % m ( j )% set ( i , x ) end subroutine subroutine set_index_matrix_r32 ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real32 ) :: x call self % m ( j )% set ( i , x ) end subroutine subroutine set_index_matrix_r64 ( self , i , j , x ) class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: i !! ith element integer , intent ( in ) :: j !! jth vector real ( real64 ) :: x call self % m ( j )% set ( i , x ) end subroutine elemental function access_vector_matrix ( self , v ) result ( vec ) !! Get a copy of the vth vector class ( matrix ), intent ( in ) :: self integer , intent ( in ) :: v type ( vector ) :: vec if ( v < 1 . or . v > self % k ) error stop \"Out of bounds index\" vec = self % m ( v ) end function elemental function gram_schmidt_matrix ( self ) result ( ortho ) class ( matrix ), intent ( in ) :: self type ( matrix ) :: ortho integer i , j , n , k n = self % n k = self % k if ( k > n ) k = n !! If there are more vectors than the dimension of the vector, only output n vectors call ortho % new ( n , k ) ! print *, \"dimension of input basis = \", self%n ! print *, \"number of basis vectors = \", self%k ! print *, \"orthonormal_basis set to 0\" ortho % m ( 1 ) = self % m ( 1 )% normalized () do i = 2 , k ortho % m ( i ) = self % m ( i ) do j = 1 , i - 1 ortho % m ( i ) = ortho % m ( i ) - ( ortho % m ( i ) . proj . ortho % m ( j )) ! ortho%m(i) = (ortho%m(i) .proj. ortho%m(j)) - ortho%m(i) end do call ortho % m ( i )% normalize () end do end function elemental function is_orthonormal_matrix ( self ) result ( bool ) class ( matrix ), intent ( in ) :: self logical :: bool integer :: i , j if ( all ( self % m % is_normal ())) then do i = 1 , self % k do j = i + 1 , self % k if (. not . self % m ( i )% is_ortho ( self % m ( j ))) then bool = . false . return end if end do end do bool = . true . else bool = . false . end if end function pure function matrix_as_array ( self ) result ( array ) class ( matrix ), intent ( in ) :: self real ( real64 ), dimension ( self % n , self % k ) :: array integer :: i forall ( i = 1 : self % k ) array ( i ,:) = self % m ( i )% data () end forall end function end module","tags":"","loc":"sourcefile/matrix.f90.html"},{"title":"gs_test_2.f90 – Fortran Program","text":"Contents Programs gs_test_2 Source Code gs_test_2.f90 Source Code program gs_test_2 use iso_fortran_env use matrix_m use vector_m implicit none type ( matrix ) :: m , ortho m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) print * , \"M: \" call m % print () ortho = m % gram_schmidt () print \"(A)\" , \"Ortho: \" call ortho % print () end program","tags":"","loc":"sourcefile/gs_test_2.f90.html"},{"title":"vec_test_2.f90 – Fortran Program","text":"Contents Programs vec_test_2 Source Code vec_test_2.f90 Source Code program vec_test_2 use matrix_m use vector_m use iso_fortran_env implicit none type ( vector ) :: v1 v1 = vector ( 2 ) v1 = [ 1 , 2 ] call v1 % print () v1 = [ 2 ] call v1 % print_info () call test_sub ( v1 , [ 2._real64 ]) contains subroutine test_sub ( self , array ) class ( vector ) :: self real ( real64 ), dimension (:) :: array if ( size ( array ) /= self % size ()) then error stop \"Please don't compile me\" end if print * , \"Array with dim =\" , size ( array ), \" passed\" end subroutine end program","tags":"","loc":"sourcefile/vec_test_2.f90.html"},{"title":"v_sub_op_speed.f90 – Fortran Program","text":"Contents Programs v_op_speed_sub Source Code v_sub_op_speed.f90 Source Code program v_op_speed_sub use vector_m implicit none integer , parameter :: N_LOOPS = 1E8 integer :: i type ( vector ) :: v1 v1 = [ 1 , 5 , - 4 , 10 ] do i = 1 , N_LOOPS call v1 % times ( 5 ) end do end program","tags":"","loc":"sourcefile/v_sub_op_speed.f90.html"},{"title":"v_n_assigment_test.f90 – Fortran Program","text":"Contents Programs v_n_assigment_test Source Code v_n_assigment_test.f90 Source Code program v_n_assigment_test !! Test whether assigment or construction is faster use vector_m implicit none type ( vector ) :: v1 integer :: i integer , parameter :: N_LOOPS = 1E7 do i = 1 , N_LOOPS v1 = [ 1 , 3 , 4 , 5 ] end do call v1 % print_info () end program","tags":"","loc":"sourcefile/v_n_assigment_test.f90.html"},{"title":"v_operator_test.f90 – Fortran Program","text":"Contents Programs operator_test Source Code v_operator_test.f90 Source Code program operator_test !! Test the functional operators use vector_m use iso_fortran_env implicit none type ( vector ) :: v1 , v2 , v3 , res , z , x , y real ( real64 ) :: scal_res v1 = [ 1 , 2 , 4 ] v2 = [ 6 , 5 , 10 ] z = [ 0 , 0 , 1 ] x = [ 1 , 0 , 0 ] y = [ 0 , 1 , 0 ] scal_res = v1 . dot . v2 print * , \"Dot product of \" , v1 % data (), \" and \" , v2 % data (), \" = \" , scal_res v3 = v1 . proj . v2 v2 = v2 % normalized () v3 = v3 % normalized () scal_res = v2 . dot . v3 print * , \"Dot product of v2 and v3 = \" , scal_res res = v1 + v2 v1 = [ 1 , 5 , 8 ] v2 = [ 1 , - 3 , - 5 ] res = v1 + v2 print * , \"v1: \" , v1 % data (), \" + \" , v2 % data (), \" = \" , res % data () res = v1 - v2 print * , \"v1: \" , v1 % data (), \" - \" , v2 % data (), \" = \" , res % data () res = v1 * 10 print * , \"v1: \" , v1 % data (), \" * 10 = \" , res % data () v2 = [ 100 , 6 , 5 ] res = v2 / 10 print * , \"v2: \" , v2 % data (), \" /10 = \" , res % data () res = v1 * v2 print * , \"v1: \" , v1 % data (), \" * \" , v2 % data (), \" = \" , res % data () res = v1 / v2 print * , \"v1: \" , v1 % data (), \" / \" , v2 % data (), \" = \" , res % data () res = 5 * v1 print * , \"5 * \" , v1 % data (), \" = \" , res % data () res = 5 / v1 print * , \"5 / \" , v1 % data (), \" = \" , res % data () res = - v1 print * , \"-(\" , v1 % data (), \") = \" , res % data () res = v1 % orthogonalized ( vector ([ 0 , 0 , 1 ])) print * , \"v1%orthogonalized([0, 0, 1]) = \" , res % data () print * , \"Scalar = \" , ( v1 . dot . z ) / ( z . dot . z ) res = v1 . proj . z print * , \"v1 .proj. z = \" , res % data () res = v1 % orthonormalized ( vector ([ 0 , 0 , 1 ])) print * , \"v1%orthogonormalized([0, 0, 1]) = \" , res % data () 99 format ( 80 ( \"=\" )) print 99 print 99 print * , \"House holder transformation tests\" print 99 print 99 res = v1 . householder . z print * , \"v1 .householder. z = \" , res % data () res = v1 . householder . y print * , \"v1 .householder. y = \" , res % data () res = v1 . householder . x print * , \"v1 .householder. x = \" , res % data () end program","tags":"","loc":"sourcefile/v_operator_test.f90.html"},{"title":"v_assignment_test.f90 – Fortran Program","text":"Contents Programs v_assignment_test Source Code v_assignment_test.f90 Source Code program v_assignment_test !! Test whether the assignments work as expected use vector_m implicit none type ( vector ) :: v1 , v2 , v3 , v4 , v5 , v6 , v7 v1 = 4 v2 = [ 4 , 2 ] v3 = [ 1.0 , 2.0 ] v4 = [ 3.d0 , 5.7d0 , 10 9.d0 , - 5 0.d0 ] v5 = v4 v6 = v5 v6 = 1 5.0 v7 = vector ( 20 ) v7 = - 1 4.d0 call v1 % print_info () call v2 % print_info () call v3 % print_info () call v4 % print_info () call v5 % print_info () call v6 % print_info () call v7 % print_info () end program","tags":"","loc":"sourcefile/v_assignment_test.f90.html"},{"title":"v_operator_sub_test.f90 – Fortran Program","text":"Contents Programs v_operator_sub_test Source Code v_operator_sub_test.f90 Source Code program v_operator_sub_test use vector_m implicit none type ( vector ) :: v1 , v2 , v3 v1 = [ 1 , 2 , 4 ] v2 = [ 6 , 5 , 10 ] v3 = v1 call v3 % proj ( v1 ) print * , v3 % data () print * , \"Starting v1: \" , v1 % data () print * , \"Starting v2: \" , v2 % data () call v1 % plus ( v2 ) print * , \"v1%plus(v2) = \" , v1 % data () call v1 % minus ( v2 ) print * , \"v1%minus(v2) = \" , v1 % data () call v1 % times ( v2 ) print * , \"v1%times(v2) = \" , v1 % data () call v1 % times ( 5 ) print * , \"v1%times(5) = \" , v1 % data () call v1 % div ( 100 ) print * , \"v1%div(100) = \" , v1 % data () call v1 % div ( v2 ) print * , \"v1%div(v2) = \" , v1 % data () call v1 % normalize () print * , \"v1%normalize() = \" , v1 % data () end program","tags":"","loc":"sourcefile/v_operator_sub_test.f90.html"},{"title":"v_constructor_test.f90 – Fortran Program","text":"Contents Programs v_constructor_test Source Code v_constructor_test.f90 Source Code program v_constructor_test !! Test whether the assignments work as expected use vector_m implicit none type ( vector ) :: v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 v1 = vector ( 5 ) !! Create empty vector(zeros) with 5 elements v2 = vector ([ 1 , 2 , 3 ]) !! Create dim 3 vector from [1, 2, 3] v3 = vector ( 4 , 0 ) !! Create 4 dim vector and fill it with 0 v4 = vector ([ 1.0 , 3.0 , 4.0 , 5.0 , 3.0 ]) v5 = vector ( 5 , 1.6 ) v6 = vector ( 10 , 1.7d0 ) v7 = vector ([ 1.4d0 , - 1 4.d0 ]) v8 = vector ( v7 ) call v1 % print_info () call v2 % print_info () call v3 % print_info () call v4 % print_info () call v5 % print_info () call v6 % print_info () call v7 % print_info () call v8 % print_info () end program","tags":"","loc":"sourcefile/v_constructor_test.f90.html"},{"title":"v_n_constructor_test.f90 – Fortran Program","text":"Contents Programs v_n_constructor_test Source Code v_n_constructor_test.f90 Source Code program v_n_constructor_test !! Test whether assigment or construction is faster use vector_m implicit none type ( vector ) :: v1 integer :: i integer , parameter :: N_LOOPS = 1E7 do i = 1 , N_LOOPS v1 = vector ([ 1 , 3 , 4 , 5 ]) end do call v1 % print_info () end program","tags":"","loc":"sourcefile/v_n_constructor_test.f90.html"},{"title":"v_fnc_op_speed.f90 – Fortran Program","text":"Contents Programs v_op_speed Source Code v_fnc_op_speed.f90 Source Code program v_op_speed use vector_m implicit none integer , parameter :: N_LOOPS = 1E8 integer :: i type ( vector ) :: v1 v1 = [ 1 , 5 , - 4 , 10 ] do i = 1 , N_LOOPS v1 = v1 * 5 end do end program","tags":"","loc":"sourcefile/v_fnc_op_speed.f90.html"},{"title":"vector – Fortran Program ","text":"type, public :: vector Contents Constructor vector Finalization Procedures vector_destructor Type-Bound Procedures size clear print_info print at set length pnorm normalize normalized orthogonalize orthogonalized orthonormalize orthonormalized householder_transform eye is_ortho is_normal data zero allocated alloc_ dealloc_ assignment(=) operator(.dot.) operator(.inner.) operator(.outer.) operator(.proj.) operator(.householder.) operator(*) operator(/) operator(+) operator(-) times div proj plus minus Constructor public interface vector Construct a vector object private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read more… Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector ) Finalization Procedures final :: vector_destructor private subroutine vector_destructor(self) Arguments Type Intent Optional Attributes Name type( vector ), intent(inout) :: self Type-Bound Procedures procedure, public :: size => vector_size Return the number of elements of the currently allocated vector private elemental function vector_size(self) result(n) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value integer procedure, public :: clear => clear_vector Deallocate the data, set dim to 0 private elemental subroutine clear_vector(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public :: print_info => vector_print_info Print diagnostic information about the vector private subroutine vector_print_info(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: print => vector_print_coordinates Print only the data stored in the vector object as a row vector private subroutine vector_print_coordinates(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self procedure, public :: at => vector_at_index Return the element x_i private elemental function vector_at_index(self, index) result(x_n) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: index Return Value real(kind=real64) generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of the element x_i at index i private elemental subroutine vector_set_index_int(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index integer, intent(in) :: val private elemental subroutine vector_set_index_r32(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real32), intent(in) :: val private elemental subroutine vector_set_index_r64(self, index, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: index real(kind=real64), intent(in) :: val procedure, public :: length => vector_euclidiean_norm Calculate the euclidean norm of a vector v private elemental function vector_euclidiean_norm(self) result(length) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64) procedure, public :: pnorm => vector_pnorm Calculate the pnorm of a vector v private elemental function vector_pnorm(self, p) result(pnorm) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: p Return Value real(kind=real64) procedure, public :: normalize => vector_normalize Normalize the elements of the passed vector v Normaliz e is a subroutine such that it alters the elements of the passed vector v to avoid costs of copying involved with a function private elemental subroutine vector_normalize(self) Normalize a vector such that its euclidian norm is 1 Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self procedure, public :: normalized => vector_normalized Return a normalized vector n pointing in the same direction as v Note The function normaliz ed is a function such that it returns a normalized version of the passed vector v private elemental function vector_normalized(self) result(normalized_vector) Normalize a vector such that its euclidian norm is 1 Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value type( vector ) procedure, public :: orthogonalize => vector_orthogonalize Orthogonalize a vector v against a passed normalized vector n Note A future version may just check if the passed vector is normalized by testing a \"normalized\" logical type that will be stored in a vector. private elemental subroutine vector_orthogonalize(self, v2) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 procedure, public :: orthogonalized => vector_orthogonalized Return a vector v that is orthogonalized against a passed normalized vector n Note This is a function that returns a new vector v private elemental function vector_orthogonalized(self, v2) result(v3) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: orthonormalize => vector_orthonormalize Orthogonalize and normalize a vector v against a passed normalized vector n Note This is a subroutine that modifies the passed vector v private elemental subroutine vector_orthonormalize(self, v2) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 procedure, public :: orthonormalized => vector_orthonormalized Return an orthogonalized and normalized vector v against a passed normalized vector n Note This is a function that returns a new vector v private elemental function vector_orthonormalized(self, v2) result(v3) Orthogonalize a vector with respect to another Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: householder_transform => vector_householder_sub Rotate a passed vector v about the hyper plane described by the passed normalized vector n Note This is a subroutine that modifies the passed vector private elemental subroutine vector_householder_sub(self, normal) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: normal MUST BE A UNIT VECTOR procedure, public :: eye => vector_constructor_eye private elemental function vector_constructor_eye(self, dim) result(v2) Construct a vector v that is equal to the dim th column of the Identity matrix I_{dim} Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self v integer, intent(in), optional :: dim Return Value type( vector ) procedure, public :: is_ortho => vector_is_orthogonal private elemental function vector_is_orthogonal(self, v2, eps) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 real(kind=real64), intent(in), optional :: eps Return Value logical procedure, public :: is_normal => vector_is_normal private elemental function vector_is_normal(self) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: data => vector_as_array private pure function vector_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%dim) procedure, public :: zero => vector_zero private elemental subroutine vector_zero(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), optional :: dim procedure, public :: allocated => vector_is_allocated private elemental function vector_is_allocated(self) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value logical procedure, public :: alloc_ => allocate_vector_data private elemental subroutine allocate_vector_data(self, dim) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: dim procedure, public :: dealloc_ => deallocate_vector_data public elemental subroutine deallocate_vector_data (self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_vector_, from_int_, from_r32_, from_r64_ private pure subroutine vector_from_array_int(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in), dimension(:) :: array private pure subroutine vector_from_array_r32(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in), dimension(:) :: array private pure subroutine vector_from_array_r64(self, array) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in), dimension(:) :: array private elemental subroutine vector_from_vector(self, v1) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v1 private pure subroutine vector_from_int(self, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: val private pure subroutine vector_from_r32(self, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in) :: val private pure subroutine vector_from_r64(self, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in) :: val generic, public :: operator(.dot.) => dot_ private elemental function vector_dot_vector(self, v2) result(inner_product) Calculate the inner product of two vectors Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.inner.) => dot_ private elemental function vector_dot_vector(self, v2) result(inner_product) Calculate the inner product of two vectors Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.outer.) => outer_ private pure function vector_outer_vector(self, v2) result(array) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value real(kind=real64),\n  dimension(self%dim, v2%dim) generic, public :: operator(.proj.) => proj_ private elemental function vector_proj_vector(self, v2) result(v3) Project vector self ONTO v2 proj_v2(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(.householder.) => householder_ private elemental function vector_householder(self, normal) result(rotated) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: normal MUST BE A UNIT VECTOR Return Value type( vector ) generic, public :: operator(*) => scalar_mult_int_, scalar_mult_r32_, scalar_mult_r64_, times_vec_ private elemental function vector_times_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) private elemental function vector_times_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(/) => scalar_div_int_, scalar_div_r32_, scalar_div_r64_, div_vec_ private elemental function vector_div_scalar_int(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self integer, intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r32(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real32), intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_scalar_r64(self, scalar) result(v2) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self real(kind=real64), intent(in) :: scalar Return Value type( vector ) private elemental function vector_div_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(+) => plus_ private elemental function vector_plus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(-) => minus_, unary_minus_ private elemental function vector_minus_vector(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self class( vector ), intent(in) :: v2 Return Value type( vector ) private elemental function vector_unary_minus(self) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Return Value type( vector ) generic, public :: times => times_int_sub_, times_r32_sub_, times_r64_sub_, times_vec_sub_ private elemental subroutine vector_times_scalar_int_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: scalar private elemental subroutine vector_times_scalar_r32_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in) :: scalar private elemental subroutine vector_times_scalar_r64_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in) :: scalar private elemental subroutine vector_times_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: div => div_int_sub_, div_r32_sub_, div_r64_sub_, div_vec_sub_ private elemental subroutine vector_div_scalar_int_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self integer, intent(in) :: scalar private elemental subroutine vector_div_scalar_r32_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real32), intent(in) :: scalar private elemental subroutine vector_div_scalar_r64_sub(self, scalar) Multiply a vector times an integer scalar Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self real(kind=real64), intent(in) :: scalar private elemental subroutine vector_div_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: proj => project_onto_sub_ private elemental subroutine vector_proj_vector_sub(self, v2) Project vector self ONTO v2 proj_v2(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: plus => plus_vector_sub_ private elemental subroutine vector_plus_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2 generic, public :: minus => minus_vector_sub_ private elemental subroutine vector_minus_vector_sub(self, v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self class( vector ), intent(in) :: v2","tags":"","loc":"type/vector.html"},{"title":"matrix – Fortran Program ","text":"type, public :: matrix Contents Type-Bound Procedures new clear print vec at gram_schmidt is_orthonormal as_array set assignment(=) Type-Bound Procedures procedure, public :: new => new_matrix Create a new matrix private elemental subroutine new_matrix(self, n, k) Wipe the contents of a matrix and allocate the proper amount of space Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self Matrix object to wipe integer, intent(in) :: n Dimension of each constituent vector integer, intent(in) :: k Number of vectors procedure, public :: clear => clear_matrix Clear all of the elements of a matrix private elemental subroutine clear_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self procedure, public :: print => print_matrix Print the contents of a matrix private subroutine print_matrix(self) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix private elemental function access_vector_matrix(self, v) result(vec) Get a copy of the vth vector Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: v Return Value type( vector ) procedure, public :: at => at_index_matrix Get the element at the index (i, j) private elemental function at_index_matrix(self, i, j) result(element) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector Return Value real(kind=real64) procedure, public :: gram_schmidt => gram_schmidt_matrix Compute an otrthonormal basis for the vector space spanned by the columns of a matrix private elemental function gram_schmidt_matrix(self) result(ortho) If there are more vectors than the dimension of the vector, only output n vectors Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value type( matrix ) procedure, public :: is_orthonormal => is_orthonormal_matrix Check whether a matrix is orthonormal private elemental function is_orthonormal_matrix(self) result(bool) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value logical procedure, public :: as_array => matrix_as_array Return a rank2 Fortran array private pure function matrix_as_array(self) result(array) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self Return Value real(kind=real64),\n  dimension(self%n, self%k) generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of (a_{i,j}) private subroutine set_index_matrix_int(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector integer, intent(in) :: x private subroutine set_index_matrix_r32(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real32) :: x private subroutine set_index_matrix_r64(self, i, j, x) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: self integer, intent(in) :: i ith element integer, intent(in) :: j jth vector real(kind=real64) :: x generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix Assign the contents of a matrix from a rank2 Fortran array private pure subroutine matrix_from_rank2_array_int(self, array) Assign a matrix from a rank2 integer array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self integer, intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r32(self, array) Assign a matrix from a rank2 single precision real array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real32), intent(in), dimension(:,:) :: array private pure subroutine matrix_from_rank2_array_r64(self, array) Assign a matrix from a rank2 double precision array Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self real(kind=real64), intent(in), dimension(:,:) :: array private elemental subroutine matrix_from_matrix(self, m) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: self class( matrix ), intent(in) :: m","tags":"","loc":"type/matrix.html"},{"title":"gram_schmidt – Fortran Program","text":"public function gram_schmidt(vector_array) result(ortho) Arguments Type Intent Optional Attributes Name class( vector ), dimension(:) :: vector_array Return Value type( vector ),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/gram_schmidt.html"},{"title":"is_orthonormal – Fortran Program","text":"public function is_orthonormal(basis) result(bool) Arguments Type Intent Optional Attributes Name class( vector ), intent(in), dimension(:) :: basis Return Value logical Contents None","tags":"","loc":"proc/is_orthonormal.html"},{"title":"deallocate_vector_data – Fortran Program","text":"public elemental subroutine deallocate_vector_data(self) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Contents None","tags":"","loc":"proc/deallocate_vector_data.html"},{"title":"print_basis – Fortran Program","text":"public subroutine print_basis(basis) Arguments Type Intent Optional Attributes Name class( vector ), intent(in), dimension(:) :: basis Contents None","tags":"","loc":"proc/print_basis.html"},{"title":"vector – Fortran Program","text":"public interface vector Construct a vector object Contents Module Procedures vector_constructor_int vector_constructor_r32 vector_constructor_r64 vector_constructor_dim vector_constructor_dim_value_int vector_constructor_dim_value_r32 vector_constructor_dim_value_r64 vector_constructor_vector Module Procedures private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read more… Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector )","tags":"","loc":"interface/vector.html"},{"title":"operator(*) – Fortran Program","text":"public interface operator(*) Contents Module Procedures int_times_vector r32_times_vector r64_times_vector Module Procedures private elemental function int_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(*).html"},{"title":"operator(/) – Fortran Program","text":"public interface operator(/) Contents Module Procedures int_div_vector r32_div_vector r64_div_vector Module Procedures private elemental function int_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(SLASH).html"},{"title":"test_sub – Fortran Program","text":"subroutine test_sub(self, array) Arguments Type Intent Optional Attributes Name class( vector ) :: self real(kind=real64), dimension(:) :: array Contents None","tags":"","loc":"proc/test_sub.html"},{"title":"vector_m – Fortran Program","text":"Attempt to play around with a vector object A vector, v has the following operations: Addition with another vector\n Multiplication with a scalar \n Inner product\n Norm (which norm?)\n Projection of a onto b The internal representaion of a vector is an array of fixed size, pointed to by a pointer.\n This way we can use the fundamental data of an array within our specific class Uses iso_fortran_env Contents Interfaces vector operator(*) operator(/) Derived Types vector Functions gram_schmidt is_orthonormal Subroutines deallocate_vector_data print_basis Interfaces public interface vector Construct a vector object private pure function vector_constructor_int(array) result(this) Construct a vector v from an array of integers Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r32(array) result(this) Construct a vector v from an array of single precision reals Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array input data Return Value type( vector ) v private pure function vector_constructor_r64(array) result(this) Construct a vector v from an array of double precision reals Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array input data Return Value type( vector ) v private elemental function vector_constructor_dim(dim) result(this) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n Return Value type( vector ) v private elemental function vector_constructor_dim_value_int(dim, val) result(this) Construct a vector v of dimension n and fill its values with integer val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n integer, intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r32(dim, val) result(this) Construct a vector v of dimension n and fill its values with single precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real32), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_dim_value_r64(dim, val) result(this) Construct a vector v of dimension n and fill its values with double precision real val Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim n real(kind=real64), intent(in) :: val val Return Value type( vector ) v private elemental function vector_constructor_vector(v1) result(v2) Construct a vector from another vector Read more… Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 Return Value type( vector ) public interface operator(*) private elemental function int_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) public interface operator(/) private elemental function int_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r32_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) private elemental function r64_div_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Derived Types type, public :: vector Constructor Construct a vector object private pure function vector_constructor_int (array) Construct a vector v from an array of integers private pure function vector_constructor_r32 (array) Construct a vector v from an array of single precision reals private pure function vector_constructor_r64 (array) Construct a vector v from an array of double precision reals private elemental function vector_constructor_dim (dim) Construct a vector by declaring its size\n Allocate an n -dimensional vector and fill its values with 0 private elemental function vector_constructor_dim_value_int (dim, val) Construct a vector v of dimension n and fill its values with integer val private elemental function vector_constructor_dim_value_r32 (dim, val) Construct a vector v of dimension n and fill its values with single precision real val private elemental function vector_constructor_dim_value_r64 (dim, val) Construct a vector v of dimension n and fill its values with double precision real val private elemental function vector_constructor_vector (v1) Construct a vector from another vector Read more… Finalizations Procedures final :: vector_destructor","tags":"","loc":"module/vector_m.html"},{"title":"matrix_m – Fortran Program","text":"A matrix is a wrapper class for a rank 1 array of vector objects. Matrices can be used to represent a variety of mathematical structures. This class is primarily used\n to bind a selection of Linear Algebra algorithms to a matrix object. Matrices can be instantiated by assignment \n of a rank2 array of any type, but the underlying data will be stored with double precision. type ( matrix ) :: m , ortho_basis m = reshape ([ 1 , 2 , 3 , 4 ], [ 2 , 2 ]) ! Create a 2x2 matrix print * , \"M: \" call m % print () ortho_basis = m % gram_schmidt () ! Compute an orthonormal basis using the Gram-Schmidt method print \"(A)\" , \"Ortho:\" call ortho_basis % print () !! output: Uses vector_m iso_fortran_env Contents Derived Types matrix Derived Types type, public :: matrix Type-Bound Procedures procedure, public :: new => new_matrix Create a new matrix procedure, public :: clear => clear_matrix Clear all of the elements of a matrix procedure, public :: print => print_matrix Print the contents of a matrix procedure, public :: vec => access_vector_matrix Get the kth vector in the matrix procedure, public :: at => at_index_matrix Get the element at the index (i, j) procedure, public :: gram_schmidt => gram_schmidt_matrix Compute an otrthonormal basis for the vector space spanned by the columns of a matrix procedure, public :: is_orthonormal => is_orthonormal_matrix Check whether a matrix is orthonormal procedure, public :: as_array => matrix_as_array Return a rank2 Fortran array generic, public :: set => set_int_, set_r32_, set_r64_ Set the value of (a_{i,j}) generic, public :: assignment(=) => from_array_int_, from_array_r32_, from_array_r64_, from_matrix Assign the contents of a matrix from a rank2 Fortran array","tags":"","loc":"module/matrix_m.html"},{"title":"gs_test_2 – Fortran Program","text":"Uses iso_fortran_env matrix_m vector_m Contents Variables m ortho Variables Type Attributes Name Initial type( matrix ) :: m type( matrix ) :: ortho","tags":"","loc":"program/gs_test_2.html"},{"title":"vec_test_2 – Fortran Program","text":"Uses matrix_m vector_m iso_fortran_env Contents Variables v1 Subroutines test_sub Variables Type Attributes Name Initial type( vector ) :: v1 Subroutines subroutine test_sub (self, array) Arguments Type Intent Optional Attributes Name class( vector ) :: self real(kind=real64), dimension(:) :: array","tags":"","loc":"program/vec_test_2.html"},{"title":"v_op_speed_sub – Fortran Program","text":"Uses vector_m Contents Variables N_LOOPS i v1 Variables Type Attributes Name Initial integer, parameter :: N_LOOPS = 1E8 integer :: i type( vector ) :: v1","tags":"","loc":"program/v_op_speed_sub.html"},{"title":"v_n_assigment_test – Fortran Program","text":"Uses vector_m Test whether assigment or construction is faster Contents Variables v1 i N_LOOPS Variables Type Attributes Name Initial type( vector ) :: v1 integer :: i integer, parameter :: N_LOOPS = 1E7","tags":"","loc":"program/v_n_assigment_test.html"},{"title":"operator_test – Fortran Program","text":"Uses vector_m iso_fortran_env Test the functional operators Contents Variables v1 v2 v3 res z x y scal_res Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: res type( vector ) :: z type( vector ) :: x type( vector ) :: y real(kind=real64) :: scal_res","tags":"","loc":"program/operator_test.html"},{"title":"v_assignment_test – Fortran Program","text":"Uses vector_m Test whether the assignments work as expected Contents Variables v1 v2 v3 v4 v5 v6 v7 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: v4 type( vector ) :: v5 type( vector ) :: v6 type( vector ) :: v7","tags":"","loc":"program/v_assignment_test.html"},{"title":"v_operator_sub_test – Fortran Program","text":"Uses vector_m Contents Variables v1 v2 v3 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3","tags":"","loc":"program/v_operator_sub_test.html"},{"title":"v_constructor_test – Fortran Program","text":"Uses vector_m Test whether the assignments work as expected Create empty vector(zeros) with 5 elements\n Create dim 3 vector from [1, 2, 3]\n Create 4 dim vector and fill it with 0 Contents Variables v1 v2 v3 v4 v5 v6 v7 v8 Variables Type Attributes Name Initial type( vector ) :: v1 type( vector ) :: v2 type( vector ) :: v3 type( vector ) :: v4 type( vector ) :: v5 type( vector ) :: v6 type( vector ) :: v7 type( vector ) :: v8","tags":"","loc":"program/v_constructor_test.html"},{"title":"v_n_constructor_test – Fortran Program","text":"Uses vector_m Test whether assigment or construction is faster Contents Variables v1 i N_LOOPS Variables Type Attributes Name Initial type( vector ) :: v1 integer :: i integer, parameter :: N_LOOPS = 1E7","tags":"","loc":"program/v_n_constructor_test.html"},{"title":"v_op_speed – Fortran Program","text":"Uses vector_m Contents Variables N_LOOPS i v1 Variables Type Attributes Name Initial integer, parameter :: N_LOOPS = 1E8 integer :: i type( vector ) :: v1","tags":"","loc":"program/v_op_speed.html"}]}